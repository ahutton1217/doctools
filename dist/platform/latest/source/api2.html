<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*
 * This code is closed source and Confidential and Proprietary to
 * Appcelerator, Inc. All Rights Reserved. This code MUST not be
 * modified, copied or otherwise redistributed without express
 * written permission of Appcelerator. This file is licensed as
 * part of the Appcelerator Platform and governed under the terms
 * of the Appcelerator license agreement.
 */

// jscs:disable
<span id='Arrow-API'>/**
</span> * @class Arrow.API
 */
// jscs:enable
var _ = require(&#39;lodash&#39;),
	util = require(&#39;util&#39;),
	fs = require(&#39;fs&#39;),
	path = require(&#39;path&#39;),
	events = require(&#39;events&#39;),
	async = require(&#39;async&#39;),
	Arrow = require(&#39;./arrow&#39;),
	pluralize = require(&#39;pluralize&#39;),
	Response = require(&#39;./response&#39;),
	paths = require(&#39;./paths&#39;),
	RequestTx = require(&#39;./request_tx&#39;),
	formatters = require(&#39;./formatters&#39;),
	express = require(&#39;express&#39;),
	apis = [],
	apiPaths = {},
	APIClass = new events.EventEmitter();

// jscs:disable jsDoc

util.inherits(API, events.EventEmitter);

function API(impl, config, arrow) {
	impl &amp;&amp; _.merge(this, impl);

	this.arrow = arrow;

	// incoming constructor config should overwrite implementation
	this.config = _.merge(impl &amp;&amp; impl.config || {}, arrow.config, config);
	this.txenabled = this.config.logging &amp;&amp; (this.config.logging.transactionLogEnabled === undefined || this.config.logging.transactionLogEnabled);
	this.enabled = impl.enabled === undefined ? true : impl.enabled;
	this.sort = impl.sort === undefined ? impl.generated ? impl.path.indexOf(&#39;:&#39;) &lt; 0 ? -1 : -2 : 1 : impl.sort;

	// if we provided a constructor in our impl, use it
	if (this.constructor &amp;&amp; this.constructor !== API &amp;&amp; !this.constructor.super_) {
		this.constructor.call(this);
		API.constructor.call(this);
	}

	if (!this.group) {
		throw new Error(&#39;required group property missing on API&#39;);
	}
	if (!this.path) {
		throw new Error(&#39;required path property missing on API&#39;);
	}
	if (!this.action) {
		throw new Error(&#39;required action property missing on API&#39;);
	}
	if (!this.description) {
		throw new Error(&#39;required description property missing on API&#39;);
	}

	// turn the model into a Model object
	if (this.model &amp;&amp; typeof(this.model) === &#39;string&#39;) {
		this.model = this.arrow.getModel(this.model, true);
	}

	// turn the models into a Model array
	if (this.models &amp;&amp; Array.isArray(this.models)) {
		this.model = null;
		this.models = this.models.map(function (name) {
			return this.arrow.getModel(name, true);
		}.bind(this));
	}

	if (!this.response) {
		this.response = this.model;

		if (!this.response &amp;&amp; this.models) {
			throw new Error(&#39;using more than one model requires a &quot;response&quot; property on the API to &#39; +
				&#39;indicate how the response should be serialized. this value should be the Model name to use for the response.&#39;);
		}
	} else {
		// get the response model
		this.response = this.arrow.getModel(this.response, true);
	}

	var singular = this.singular,
		plural = this.plural;

	if (this.model) {
		this.singular = makeResponseKey(singular || this.model.singular || this.model.name, 1);
		this.plural = makeResponseKey(plural || this.model.plural || this.model.name);
	}
	if (this.response) {
		// use the response if multiple models
		this.singular = makeResponseKey(singular || this.response.singular || this.response.name, 1);
		this.plural = makeResponseKey(plural || this.response.plural || this.response.name);
	}

	// pre/post -&gt; before/after.  you pick.
	this.pre = this.pre || this.before;
	this.post = this.post || this.after;

	function getBlock(name) {
		if (_.isFunction(name)) {
			return function blockMiddleware(req, resp, next) {
				try {
					var blockFn = name;
					if (blockFn) {
						if (blockFn.length === 3) {
							blockFn(req, resp, next);
						} else {
							blockFn(req, resp);
							next();
						}
					} else {
						return next();
					}
				}
				catch (E) {
					next(E);
				}
			}.bind(this);
		} else {
			return this.arrow.getBlock(name, true).getMiddleware();
		}
	}

	// load the pre block(s)
	if (this.pre) {
		if (typeof(this.pre) === &#39;string&#39;) {
			this.pre = [this.arrow.getBlock(this.pre, true).getMiddleware()];
		} else if (Array.isArray(this.pre)) {
			this.pre = this.pre.map(getBlock.bind(this));
		} else {
			throw new Error(&#39;unknown block type (pre)&#39;);
		}
		if (this.pre.length === 0) {
			delete this.pre;
		}
	}

	// load the post block(s)
	if (this.post) {
		if (typeof(this.post) === &#39;string&#39;) {
			this.post = [this.arrow.getBlock(this.post, true).getMiddleware()];
		} else if (Array.isArray(this.post)) {
			this.post = this.post.map(getBlock.bind(this));
		} else {
			throw new Error(&#39;unknown block type (post)&#39;);
		}
		if (this.post.length === 0) {
			delete this.post;
		}
	}

	// programmers are lazy, allow both
	this.parameters = this.parameters || this.params;

	var method = (this.method || &#39;GET&#39;).toUpperCase();
	if (!this.parameters &amp;&amp; this.model &amp;&amp; /(PUT|POST)/.test(method)) {
		var bodyfields = {},
			model = this.model,
			localSingular = this.singular;
		// we pull out our fields so that we can generate the PUT/POST parameters
		Object.keys(model.fields).forEach(function (name) {
			var field = model.fields[name],
				required = (field.optional === undefined &amp;&amp; field.required === undefined &amp;&amp; field.default) || field.required || !field.optional;
			if (!field.readonly) {
				bodyfields[name] = {
					description: field.description || &#39;the &#39; + localSingular + &#39; &#39; + name + &#39; field&#39;,
					type: &#39;body&#39;,
					optional: !required,
					required: required
				};
			}
		});
		if (method === &#39;PUT&#39;) {
			bodyfields.id = {description: &#39;primary key id&#39;, optional: false, type: &#39;body&#39;};
		}
		this.parameters = bodyfields;
	}

	var params = this.path.split(&#39;/&#39;),
		parts = [],
		foundParams = [];
	params.forEach(function (name) {
		if (name.charAt(0) === &#39;:&#39;) {
			name = name.substring(1);
			var optional = false;
			if (name.charAt(name.length - 1) === &#39;?&#39;) {
				name = name.substring(0, name.length - 1);
				optional = true;
			}
			var param = this.parameters &amp;&amp; this.parameters[name];
			if (!param) {
				throw new Error(&#39;missing parameters definition for path parameter: &#39; + name);
			}
			param.optional = optional;
			param.name = name;
			param.type = &#39;path&#39;;
			foundParams.push(name);
		} else {
			parts.push(name);
		}
	}.bind(this));

	var key = parts.join(&#39;/&#39;);
	if (key in apiPaths) {
		apiPaths[key].push(this);
	} else {
		apiPaths[key] = [this];
	}
	arrow.logger.debug(&#39;registering&#39; + (this.enabled ? &#39;&#39; : &#39; disabled&#39;) + &#39; api&#39;, this.method, this.path);

	// register by nickname as well as path
	if (this.nickname) {
		if (this.nickname in apiPaths) {
			apiPaths[this.nickname].push(this);
		} else {
			apiPaths[this.nickname] = [this];
		}
		arrow.logger.debug(&#39;registering api (nickname)&#39;, this.nickname);
	} else {
		// the nickname should just be the path so we have one
		this.nickname = method + &#39; &#39; + key;
	}
	this.key = key;

	this.parameters &amp;&amp; Object.keys(this.parameters).forEach(function (name) {
		var param = this.parameters[name];
		if (!param.description) {
			throw new Error(&#39;missing description for parameter: &#39; + name);
		}
		param.optional = !!param.optional;
		param.name = name;
		param.type = param.type || &#39;query&#39;;
		if (!/^(query|body|path)$/.test(param.type)) {
			throw new Error(&#39;invalid type: &#39; + param.type.toString() + &#39; for &#39; + name + &#39; parameter. only \&#39;body\&#39;, \&#39;path\&#39; and \&#39;query\&#39; are accepted&#39;);
		}
		if (param.type === &#39;path&#39; &amp;&amp; foundParams.indexOf(name) === -1) {
			throw new Error(&#39;found path parameter: &#39; + name + &#39; but not defined in route&#39;);
		}
	}.bind(this));

	// handle in built-in events
	if (this.beforeEvent) {
		if (!_.isString(this.beforeEvent)) {
			throw new Error(&#39;unsupported type for beforeEvent &quot;&#39; + this.beforeEvent + &#39;&quot;. must be a string which is the name of the event&#39;);
		}
	}
	if (this.afterEvent) {
		if (!_.isString(this.afterEvent)) {
			throw new Error(&#39;unsupported type for afterEvent &quot;&#39; + this.afterEvent + &#39;&quot;. must be a string which is the name of the event&#39;);
		}
	}
	if (this.eventTransformer) {
		if (_.isString(this.eventTransformer)) {
			var fn = path.resolve(process.cwd(), this.eventTransformer);
			if (!fs.existsSync(fn)) {
				throw new Error(&#39;path not found to eventTransformer module:  &#39; + fn);
			}
			this.eventTransformerSource = fn;
			this.eventTransformer = require(fn);
		} else if (!_.isFunction(this.eventTransformer)) {
			throw new Error(&#39;unsupported type for eventTransformer &quot;&#39; + this.eventTransformer + &#39;&quot;. must be either path to a module or function&#39;);
		} else {
			this.eventTransformerSource = this.eventTransformer;
		}
	}
}

function makeResponseKey(value, count) {
	// remove any slashes in the case of something like appc.foo/modelname
	var i = value.lastIndexOf(&#39;/&#39;);
	if (i &gt; 0) {
		value = value.substring(i + 1);
	}
	return pluralize(value.toLowerCase(), count);
}

API.on = function on() {
	APIClass.on.apply(APIClass, arguments);
};

API.removeListener = function removeListener() {
	APIClass.removeListener.apply(APIClass, arguments);
};

API.removeAllListeners = function removeAllListeners() {
	APIClass.removeAllListeners.apply(APIClass, arguments);
};

// NOTE: this is internal and only used by the test and should never be called directly
API.clearAPIs = function clearAPIs() {
	apis.length = 0;
};

<span id='Arrow-API-static-method-getAPIsForPath'>/**
</span> * Returns an API for the given path.
 * @static
 * @param {String} path API path.
 * @returns {Array&lt;Arrow.API&gt;}
 */
API.getAPIsForPath = function (path) {
	return apiPaths[path];
};

<span id='Arrow-API-static-method-extend'>/**
</span> * Returns a constructor function to generate a new API endpoint.
 * Pass the constructor an Arrow configuration object, Arrow instance, and optionally a filename.
 * @static
 * @param {Dictionary&lt;Arrow.API&gt;} impl Implementation object.
 * @returns {Function}
 * @throws {Error} Missing required parameter.
 */
API.extend = function classExtend(impl) {
	return function APIConstructor(config, arrow, fn) {
		if (!arrow) {
			throw new Error(&#39;invalid constructor. must be called with arrow instance as 2nd argument&#39;);
		}
		var api = new API(impl, config, arrow);
		api.filename = fn;
		fn &amp;&amp; (api.timestamp = fs.statSync(fn).mtime);
		return api;
	};
};

<span id='Arrow-API-method-extend'>/**
</span> * Returns a constructor function to generate a new API by extending this instance.
 * Pass the constructor an Arrow configuration object, Arrow instance, and optionally a filename.
 * @param {Dictionary&lt;Arrow.API&gt;} impl Implementation object.
 * @returns {Function}
 * @throws {Error} Missing required parameter.
 */
API.prototype.extend = function instanceExtend(impl) {
	return API.extend(_.merge(this, impl));
};

<span id='Arrow-API-method-executeEventTransform'>/**
</span> * Handles event transformation if a eventTransformer property is set on the API
 */
API.prototype.executeEventTransform = function (when, name, data, req, resp, callback) {
	if (this.eventTransformer) {
		var context = {
			when: when,
			name: name,
			request: req,
			response: resp,
			data: req.params,
			api: this,
			payload: _.cloneDeep(data)
		};
		if (this.eventTransformer.length &gt; 1) {
			this.eventTransformer(context, callback);
		} else {
			var newdata = this.eventTransformer(context, this);
			callback(null, newdata);
		}
	} else {
		callback(null, data);
	}
};

<span id='Arrow-API-method-getRequestURL'>/**
</span> * for a request, return a url
 */
function getRequestURL(req) {
	return &#39;http&#39; + (req.secure ? &#39;s&#39; : &#39;&#39;) + &#39;://&#39; + req.get(&#39;host&#39;) + req.originalUrl;
}

<span id='Arrow-API-method-executeBeforeEvent'>/**
</span> * Handles sending pubsub event if beforeEvent property is set on the API
 */
API.prototype.executeBeforeEvent = function (req, resp, callback) {
	var name = this.beforeEvent;
	if (req.server.pubsub) {
		var payload = {
			parameters: req.params,
			type: &#39;before&#39;,
			name: this.nickname,
			path: this.path,
			method: this.method,
			reqid: req.getId(),
			url: getRequestURL(req),
			serverid: process.env.serverId,
			appid: process.env.appid
		};
		var pubsub = req.server.pubsub;
		this.executeEventTransform(&#39;before&#39;, name, payload, req, resp, function (err, data) {
			if (err) { return callback(err); }
			if (data !== false) { pubsub.publish(name, data || payload); }
			callback();
		});
	} else {
		req.logger.warn(&#39;before event: &#39; + name + &#39; not fired since there is no configured pubsub connection&#39;);
		callback();
	}
};

<span id='Arrow-API-method-executeAfterEvent'>/**
</span> * Handles sending pubsub event if afterEvent property is set on the API
 */
API.prototype.executeAfterEvent = function (req, resp, callback) {
	var name = this.afterEvent;
	if (req.server.pubsub) {
		var body = resp.unformattedBody || resp.rawbody || resp.body;
		var data = body &amp;&amp; body.key &amp;&amp; body[body.key] || body;
		var payload = {
			response: data,
			type: &#39;after&#39;,
			name: this.nickname,
			path: this.path,
			method: this.method,
			url: getRequestURL(req),
			serverid: process.env.serverId,
			appid: process.env.appid
		};
		var pubsub = req.server.pubsub;
		this.executeEventTransform(&#39;after&#39;, name, payload, req, resp, function (err, data) {
			if (err) { return callback(err); }
			if (data !== false) { pubsub.publish(name, data || payload); }
			callback();
		});
	} else {
		req.logger.warn(&#39;after event: &#39; + name + &#39; not fired since there is no configured pubsub connection&#39;);
		callback();
	}
};

function InteruptedError() {}

function invoke(api, fn, req, resp, tx, next, isBlock) {
	// console.log(&#39;invoke&#39;, fn, new Error().stack);
	// if we&#39;ve already invoked an api, we only run it once
	if (!isBlock &amp;&amp; req._alreadyCalled) {
		return next();
	}
	// if we have a callback, handle it async
	req.params &amp;&amp; tx &amp;&amp; tx.addArguments(req.params);
	if (fn.length === 3) {
		var alreadyCalled = false;
		var callback = function invokeCallback(err, results) {
			// Did we receive our results from an async waterfall?
			if (results &amp;&amp; Array.isArray(results) &amp;&amp; results.length === 2) {
				// If so, one will be truthy, and the other falsy, or both will be falsy.
				if ((!results[0] &amp;&amp; results[1]) || (results[0] &amp;&amp; !results[1]) || (!results[0] &amp;&amp; !results[1])) {
					results = results[0];
				}
			}
			// only run the callback once and only invoke the first API available, otherwise fall through
			// to the next middleware in the stack
			if (!isBlock &amp;&amp; (alreadyCalled || req._alreadyCalled)) {
				if (next) {
					try { next(); } catch (E) { req.logger.trace(E); }
				}
				next = null;
				return;
			}
			alreadyCalled = true;
			// this is an interrupted chain. stop processing
			if (err === false) {
				return next(new InteruptedError());
			}
			if (tx) {
				if (err) {
					tx.addError(err);
				}
				if (results) {
					tx.addResult(results);
				}
				tx.end();
			}
			if (resp._sendCalled || isBlock) {
				return next(err);
			}
			// err &amp;&amp; console.log(err &amp;&amp; err.stack);
			if (err) {
				if (!err.message &amp;&amp; /trying to remove, couldn&#39;t find record with primary key:/.test(err)) {
					return resp.notFound(next);
				}
				return next(err);
			} else {
				var method = api.method,
					noResult = (results === undefined || results === null);
				switch (method) {
					case &#39;GET&#39;:
						if (!isBlock) { req._alreadyCalled = !noResult; }
						return noResult ? next() : resp.success(results, next);
					case &#39;POST&#39;:
						if (results &amp;&amp; _.isFunction(results.getMeta) &amp;&amp; results.getMeta(&#39;includeResponseBody&#39;)) {
							if (!isBlock) { req._alreadyCalled = true; }
							return resp.success(results, next);
						} else if (results &amp;&amp; results.getPrimaryKey &amp;&amp; api.generated) {
							if (!isBlock) { req._alreadyCalled = true; }
							if (api.nickname === &#39;Upsert&#39; &amp;&amp; api.generated &amp;&amp; req.params.id) {
								return resp.noContent(next);
							} else {
								return resp.redirectPath(results.getPrimaryKey(), next, 201);
							}
						}
						break;
					case &#39;PUT&#39;:
					case &#39;DELETE&#39;:
						if (!isBlock) { req._alreadyCalled = true; }
						return resp.noContent(next);
					default:
						break;
				}
				// indicate we&#39;ve already done an API so only one API is ever matched
				if (!isBlock) { req._alreadyCalled = !noResult; }
				return noResult ? next() : results ? resp.success(results, next) : resp.noContent(next);
			}
		};
		fn.apply(null, [req, resp, callback]);
	} else {
		// else if we don&#39;t have a callback we can just deal with it synchronously
		fn.apply(null, [req, resp]);
		tx &amp;&amp; tx.end();
		next();
	}
}

/*
 * Gets the middleware block that provides access to the
 * API&#39;s action implementation.
 * Pass the function returned by this method an Express request object,
 * Express response object, Arrow Response object and the function to call next.
 * @returns {Function}
 */
API.prototype.getMiddleware = function getMiddleware() {
	var api = this,
		metadata,
		apiname = this.nickname,
		arrow = this.arrow;
	if (api.generated) {
		metadata = _.pick(api, &#39;path&#39;, &#39;method&#39;, &#39;parameters&#39;);
		if (api.pre) {
			metadata.pre = api.pre.name;
		}
		if (api.post) {
			metadata.post = api.post.name;
		}
		if (api.model) {
			metadata.model = api.model.name;
		}
	}
	return function MiddlewareConstructor(req, resp, r, next) {
		if (req._middlewareExecuted) {
			return next();
		}
		req._middlewareExecuted = true;
		var _next = next;
		req.logmetadata = true;
		return api.arrow.executeSecurityMiddleware(req, resp, function (err) {
			if (err) { return next(err); }
			// if the auth plugin changed the status code, bail
			if (resp.statusCode !== 200) {
				return next();
			}
			// if the api is not allowed, return 405
			if (!api.enabled) {
				return r.notAllowed(next);
			}
			try {
				next = function next() {
					// ensure next only ever gets called once
					if (_next) {
						var fn = _next;
						_next = null;
						return fn.apply(this, arguments);
					}
				};

				// we use our hidden variable from our main middleware because express
				// overwrites for each call to next. however, in route params it&#39;s there in params
				// so we have to merge them
				req.params = _.merge(_.merge({}, req._params), req.params);
				var qkeys = req.query &amp;&amp; Object.keys(req.query),
					bkeys = req.body &amp;&amp; _.isObject(req.body) &amp;&amp; !(req.body instanceof Buffer) &amp;&amp; Object.keys(req.body);

				// validate incoming parameters (query only)
				if (qkeys &amp;&amp; qkeys.length &amp;&amp; !this.parameters &amp;&amp; !this.wildcardParameters) {
					return r.badRequest(&#39;query parameters sent but missing in API definition&#39;, next);
				}
				if (bkeys &amp;&amp; bkeys.length &amp;&amp; !this.parameters &amp;&amp; !this.wildcardParameters) {
					return r.badRequest(&#39;body parameters sent but missing in API definition&#39;, next);
				}

				arrow.logger.trace(&#39;┌ Processing Request:&#39;);
				arrow.logger.trace(&#39;├ url&#39;, req.url);
				if (req.body &amp;&amp; Object.keys(req.body).length) {
					if (req.body instanceof Buffer) {
						arrow.logger.trace(&#39;├ body&#39;, &#39;&lt;Buffer length:&#39; + req.body.length + &#39;&gt;&#39;);
					} else {
						arrow.logger.trace(&#39;├ body&#39;, req.body);
					}
				}
				if (req.query &amp;&amp; Object.keys(req.query).length) {
					arrow.logger.trace(&#39;├ query&#39;, req.query);
				}
				if (req.params &amp;&amp; Object.keys(req.params).length) {
					arrow.logger.trace(&#39;├ params&#39;, req.params);
				}
				if (req.files) {
					arrow.logger.trace(&#39;├ files&#39;, req.files);
				}
				arrow.logger.trace(&#39;└&#39;);

				if (this.parameters) {
					var params = Object.keys(this.parameters);
					for (var c = 0; c &lt; params.length; c++) {
						var key = params[c],
							param = this.parameters[key],
							required = (param.required === undefined &amp;&amp; param.optional === undefined &amp;&amp; param.default === undefined) || !param.optional || param.required;
						if (req.query &amp;&amp; key in req.query) {
							qkeys.splice(qkeys.indexOf(key), 1);
							if (!(key in req.params)) {
								req.params[key] = req.query[key];
							}
						} else if (req.body &amp;&amp; key in req.body) {
							bkeys.splice(bkeys.indexOf(key), 1);
							if (!(key in req.params)) {
								req.params[key] = req.body[key];
							}
						} else if (req.files &amp;&amp; key in req.files) {
							req.params[key] = req.files[key].file;
						} else if (required &amp;&amp; param.type !== &#39;path&#39; &amp;&amp; !(key in req.params)) {
							arrow.logger.trace(&#39;required params key not found: &#39; + key, param);
							return r.badRequest(&#39;required &#39; + param.type + &#39; parameter: &#39; + key + &#39; missing&#39;, next);
						}
					}
					if (qkeys &amp;&amp; qkeys.length &amp;&amp; !this.wildcardParameters) {
						arrow.logger.trace(&#39;required query key not found: &#39;, qkeys);
						return r.badRequest(&#39;query parameters: &#39; + qkeys.join(&#39;, &#39;) + &#39; missing in API definition&#39;, next);
					}
					if (bkeys &amp;&amp; bkeys.length &amp;&amp; !this.wildcardParameters) {
						arrow.logger.trace(&#39;required body key not found: &#39;, bkeys);
						return r.badRequest(&#39;body parameters: &#39; + bkeys.join(&#39;, &#39;) + &#39; missing in API definition&#39;, next);
					}
				}
				// NOTE: we don&#39;t need to validate path parameters since we get that for free
				// as part of express routing

				// map in our model if we have one
				if (this.model) {
					req.model = r.model = this.model.createRequest(req, resp);
				} else if (this.models) {
					req.models = r.models = this.models.forEach(function modelIterator(model) {
						return model.createRequest(req, resp);
					});
				}
				if (this.response) {
					req.responseModel = r.responseModel = this.response.createRequest(req, resp);
				}

				// if we have blocks, we need to execute them
				if (this.pre || this.post || this.beforeEvent || this.afterEvent) {
					var tasks = [];
					if (this.pre) {
						this.pre.forEach(function preIterator(block) {
							tasks.push(function preIteratorTask(next_) {
								try {
									var pretx = req.tx &amp;&amp; req.tx.start(&#39;pre:&#39; + block._name, false, block.filename, block.description);
									invoke(api, block, req, r, pretx, next_, true);
								}
								catch (E) {
									next_(E);
								}
							});
						});
					}
					if (this.beforeEvent) {
						tasks.push(function beforeEventTask(next_) {
							try {
								var pretx = req.tx &amp;&amp; req.tx.start(&#39;preevent:&#39; + api.beforeEventName, false, api.beforeEventSource);
								invoke(api, api.executeBeforeEvent.bind(api), req, r, pretx, next_, true);
							}
							catch (E) {
								next_(E);
							}
						});
					}
					var action_ = this.action;
					tasks.push(function actionTask(next_) {
						try {
							var actiontx = req.tx &amp;&amp; req.tx.start(&#39;action:api:&#39; + apiname, false, api.filename, api.description, metadata);
							invoke(api, action_, req, r, actiontx, next_);
						}
						catch (E) {
							next_(E);
						}
					});
					if (this.post) {
						this.post.forEach(function postIterator(block) {
							tasks.push(function postIteratorTask(next_) {
								try {
									var posttx = req.tx &amp;&amp; req.tx.start(&#39;post:&#39; + block._name, false, block.filename, block.description);
									invoke(api, block, req, r, posttx, next_, true);
								}
								catch (E) {
									next_(E);
								}
							});
						});
					}
					if (this.afterEvent) {
						tasks.push(function afterEventTask(next_) {
							try {
								var pretx = req.tx &amp;&amp; req.tx.start(&#39;postevent:&#39; + api.afterEventName, false, api.afterEventSource);
								invoke(api, api.executeAfterEvent.bind(api), req, r, pretx, next_, true);
							}
							catch (E) {
								next_(E);
							}
						});
					}
					return async.series(tasks, function callback(err) {
						if (err &amp;&amp; err instanceof InteruptedError) {
							// this is OK, just used to stop processing
							err = null;
						}
						if (err) { r.error(err); }
						r.flushBody();
						if (!err) { next(); }
					}.bind(this));
				} else {
					var actiontx = req.tx &amp;&amp; req.tx.start(&#39;action:api:&#39; + apiname, false, api.filename, api.description, metadata);
					invoke(api, this.action, req, r, actiontx, function (err) {
						if (err &amp;&amp; err instanceof InteruptedError) {
							// this is OK, just used to stop processing
							err = null;
						}
						if (err) {
							req.log.trace(err.stack);
							r.error(err, next);
						}
						r.flushBody();
						actiontx &amp;&amp; actiontx.end();
						if (!err) { next(); }
					});
				}
			}
			catch (E) {
				console.error(E.stack);
				req.logger.error(E, E.stack);
				next(E);
			}
		}.bind(this));
	}.bind(this);
};

<span id='Arrow-API-method-remove'>/**
</span> * Removes the API from the Arrow instance.
 * @param {Object} arrow Arrow instance.
 * @param {Function} [callback] Callback passed an Error object (or null if successful) and the removed API.
 */
API.prototype.remove = function (arrow, callback) {
	var self = this;
	arrow.apis = _.reject(arrow.apis, function (e) {
		return e === self;
	});
	// remove the routing entry from express
	var array = arrow.app._router.stack;
	var keys = Object.keys(formatters.extensions).join(&#39;|&#39;);
	var removeIndices = [];
	for (var c = 0; c &lt; array.length; c++) {
		var entry = array[c],
			re = new RegExp(&#39;^&#39; + this.path.replace(/\//g, &#39;\\/&#39;) + &#39;\\.(&#39; + keys + &#39;)$&#39;);
		if (entry.route &amp;&amp; (entry.route.path === this.path || re.test(entry.route.path))) {
			var stack = entry.route.stack;
			for (var i = 0; i &lt; stack.length; i++) {
				if (stack[i].method.toLowerCase() === this.method.toLowerCase()) {
					stack.splice(i, 1);
					break;
				}
			}
			// no more routes, mark to later remove it
			if (stack.length === 0) {
				removeIndices.push(entry);
			}
		}
	}
	if (removeIndices.length) {
		removeIndices.forEach(function (entry) {
			for (var c = 0; c &lt; array.length; c++) {
				if (entry === array[c]) {
					array.splice(c, 1);
				}
			}
		});
	}
	callback &amp;&amp; callback(null, this);
};

<span id='Arrow-API-method-reload'>/**
</span> * Reloads the API for the Arrow instance.
 * @param {Object} arrow Arrow instance.
 * @param {Function} [callback] Callback passed an Error object (or null if successful) and the reloaded API.
 */
API.prototype.reload = function (arrow, callback) {
	if (this.filename) {
		this.timestamp = fs.statSync(this.filename).mtime;
		var old = this;
		// remove the route
		this.remove(arrow, function () {
			// remove it from the arrow
			arrow.loadApi(old.filename, function (err, api) {
				callback &amp;&amp; callback(err, old, api);
			});
		});
	} else {
		callback &amp;&amp; callback(null, this);
	}
};

<span id='Arrow-API-method-bind'>/**
</span> * Binds this API to the app instance
 * @param {Object} app App instance.
 * @throws {Error} Missing app instance.
 */
API.prototype.bind = function (app) {
	if (!app) { throw new Error(&#39;app required for bind&#39;); }
	var method = (this.method || &#39;GET&#39;).toLowerCase(),
		middleware = this.middleware = this.getMiddleware(),
		api = this;
	this.app = app;
	app.logger.debug(&#39;binding&#39; + (this.enabled ? &#39;&#39; : &#39; disabled&#39;) + &#39; api (&#39; + method + &#39;) &#39; + this.path, this.generated ? &#39;[model]&#39; : &#39;[api]&#39;, &#39;sort:&#39; + this.sort);

	function createAPIBinding(preCallback) {
		return function apiBinding(req, resp, next) {
			if (preCallback) {
				preCallback(req);
			}
			var status = resp.statusCode,
				r = new Response(req, resp, api);
			middleware(req, resp, r, function middlewareCallback(err, result) {
				if (err) {
					return next(err);
				}
				if (result) {
					return next(null, result);
				}
				if (status === resp.statusCode) {
					next();
				} else {
					r.flushBody();
				}
				r.done();
			});
		};
	}

	// add a route for each extension
	Object.keys(formatters.extensions).forEach(function (extension) {
		var mimeType = formatters.extensions[extension];
		var extensionRoute = app[method](api.path + &#39;.&#39; + extension, createAPIBinding(function (req) {
			req.headers.accept = mimeType;
		}));
	});

	// add the explicit route
	this.route = app[method](this.path, createAPIBinding());
};

function emptyFn() {}

<span id='Arrow-API-method-execute'>/**
</span> * Executes this API with the specified parameters.
 * Results are sent to to the callback.
 * @param {Object} params API parameters.
 * @param {Function} callback Callback passed an Error object (or null if successful) and the results.
 */
API.prototype.execute = function (params, callback) {
	if (_.isFunction(params)) {
		callback = params;
		params = {};
	}
	var request = {__proto__: this.app.request, app: this.app};
	var response = {__proto__: this.app.response, app: this.app};

	request.url = this.path;
	request.params = params;
	request.method = this.method;
	request.headers = {&#39;accept&#39;: &#39;application/json&#39;};
	response.headers = response._headers = {};
	response.setHeader = response.set = emptyFn;
	request.Arrow = {};
	request.session = response.session = request.Arrow;
	request.session.destroy = response.session.destroy = emptyFn;
	request.logger = response.logger = request.log = response.log = this.arrow.logger;
	request.tx = this.txenabled &amp;&amp; new RequestTx(request, response, this.arrow.config.admin.prefix);
	request.skipSecurityCheck = true;
	request.server = this.arrow;

	var r = new Response(request, response, this);
	r.flushBody = emptyFn;
	r.skipFormatting = true;

	try {
		// execute the middleware
		this.middleware(request, response, r, function (err, result) {
			// handle error scenarios
			if (err) { return callback(err); }
			result = r.rawbody || result;
			if (result &amp;&amp; result.success === false) {
				err = new Error(result.message || &#39;error&#39;);
				err.result = result;
				err.code = result.code;
				return callback(err);
			} else if (response.statusCode &gt; 299) {
				var http = require(&#39;http&#39;);
				err = new Error(http.STATUS_CODES[response.statusCode]);
				err.body = r.rawbody;
				err.code = response.statusCode;
				return callback(err);
			}
			// make sure to convert any collection, models into JSON
			var value = result &amp;&amp; result.key &amp;&amp; result[result.key];
			if (value &amp;&amp; (value instanceof Arrow.Instance || value instanceof Arrow.Collection || _.isFunction(value.toJSON))) {
				result[result.key] = value.toJSON();
			}
			return callback(null, result);
		});
	}
	catch (E) {
		callback(E);
	}
};

module.exports = API;
</pre>
</body>
</html>
