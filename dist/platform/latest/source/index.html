<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">var fs = require(&#39;fs&#39;),
	path = require(&#39;path&#39;),
	chalk = require(&#39;chalk&#39;);

/*
 Public API.
 */

exports.validateCapabilities = validateCapabilities;
/*
 * Generates tests based upon the capabilities you have specified.
 */
exports.generateTests = require(&#39;./generateTests&#39;);

<span id='Arrow-Capabilities'>/**
</span> * @class Arrow.Capabilities
 * Defines various connector specific capabilities; these are used by the validator to help developer&#39;s add new
 * functionality to their connectors.
 * @since 1.2.8
 */
var Capabilities = exports.Capabilities = {
<span id='Arrow-Capabilities-property-ConnectsToADataSource'>	/**
</span>	 * Specifies that the first time the connector is used, it will need to connect to a particular
	 * data source before it can be used. For example, the MySQL connector connects to a MySQL server.
	 */
	ConnectsToADataSource: &#39;ConnectsToADataSource&#39;,
<span id='Arrow-Capabilities-property-ValidatesConfiguration'>	/**
</span>	 * Define validation on your validation files to ensure you get the data you need to run.
	 * For example, a MongoDB connector could require a valid URL.
	 */
	ValidatesConfiguration: &#39;ValidatesConfiguration&#39;,
<span id='Arrow-Capabilities-property-AddsCustomTypes'>	/**
</span>	 * Connectors can provide custom types of objects, such as a MongoDB ObjectID.
	 */
	AddsCustomTypes: &#39;AddsCustomTypes&#39;,
<span id='Arrow-Capabilities-property-GeneratesModels'>	/**
</span>	 * Connectors can dynamically create models based upon loaded schema from their data sources.
	 */
	GeneratesModels: &#39;GeneratesModels&#39;,
<span id='Arrow-Capabilities-property-ContainsModels'>	/**
</span>	 * Connectors can contain static models, defined in their &quot;models&quot; directory.
	 */
	ContainsModels: &#39;ContainsModels&#39;,
<span id='Arrow-Capabilities-property-CanCreate'>	/**
</span>	 * Enables a &quot;create&quot; method on this connector&#39;s models.
	 */
	CanCreate: &#39;CanCreate&#39;,
<span id='Arrow-Capabilities-property-CanRetrieve'>	/**
</span>	 * Enables several methods such as findAll, findByID, or query on this connector&#39;s models.
	 */
	CanRetrieve: &#39;CanRetrieve&#39;,
<span id='Arrow-Capabilities-property-CanUpdate'>	/**
</span>	 * Enables an &quot;update&quot; method on this connector&#39;s models.
	 */
	CanUpdate: &#39;CanUpdate&#39;,
<span id='Arrow-Capabilities-property-CanDelete'>	/**
</span>	 * Enables several methods such as delete and deleteAll on this connector&#39;s models.
	 */
	CanDelete: &#39;CanDelete&#39;,
<span id='Arrow-Capabilities-property-AuthenticatesThroughConnector'>	/**
</span>	 * In addition to (or in place of) authenticating users in Arrow, the connector itself can validate a user
	 * when a request is made to one of the connector&#39;s exposed methods. This is done through the user of headers.
	 * For example, the Salesforce connector allows you to pass a Salesforce username, password, and token, or
	 * an access token. Then all queries are made as this provided user, allowing the connector to leverage Salesforce&#39;s
	 * access controls very easily.
	 */
	AuthenticatesThroughConnector: &#39;AuthenticatesThroughConnector&#39;
};

/*
 Implementation.
 */

var validations = {
	ConnectsToADataSource: function (impl) {
		return impl.connect;
	},
	AddsCustomTypes: function (impl) {
		return impl.coerceCustomType &amp;&amp; impl.getCustomType;
	},
	ValidatesConfiguration: function (impl) {
		return impl.fetchMetadata;
	},
	GeneratesModels: function (impl) {
		return impl.fetchSchema &amp;&amp; impl.createModelsFromSchema;
	},
	ContainsModels: function (impl) {
		if (impl.models &amp;&amp; Object.keys(impl.models).length &gt; 0) {
			return true;
		}
		// If models is empty, it&#39;s probably because we are waiting for the connector to finish loading first.
		return impl.modelsDir &amp;&amp; fs.readdirSync(impl.modelsDir)
				.filter(function (f) {
					return f.slice(-3) === &#39;.js&#39;;
				}).length &gt; 0;
	},
	CanCreate: function (impl) {
		return impl.create;
	},
	CanRetrieve: function (impl) {
		return impl.findByID || impl.findById || impl.findOne || impl.findAll || impl.query || impl.distinct;
	},
	CanUpdate: function (impl) {
		return impl.save || impl.upsert || impl.findAndModify;
	},
	CanDelete: function (impl) {
		return impl.delete || impl.deleteAll;
	},
	AuthenticatesThroughConnector: function (impl) {
		return impl.loginRequired &amp;&amp; impl.login;
	}
};

function validateCapabilities(impl) {
	var connectorDir = path.resolve(path.join(impl.filename, &#39;..&#39;, &#39;..&#39;)),
		mightBeEmpty = Object.keys(impl).length &lt;= 5 &amp;&amp; impl.filename &amp;&amp; impl.logger &amp;&amp; impl.pkginfo &amp;&amp; impl.defaultConfig &amp;&amp; impl.capabilities !== undefined,
		failed = false;

	for (var i = 0; i &lt; impl.capabilities.length; i++) {
		var capability = impl.capabilities[i];
		if (validations[capability] !== undefined) {
			if (!validations[capability](impl)) {
				failed = true;
				console.log(&#39;&#39;);
				console.log(chalk.green(&#39;The &quot;&#39; + chalk.underline(capability) + &#39;&quot; capability has been enabled, so we need to make a couple of changes:&#39;));

				var templateDir = path.join(__dirname, &#39;templates&#39;, capability);

				crawlTemplates(connectorDir, templateDir);

				logIfExists(path.join(templateDir, &#39;notes.txt&#39;));
			}
			else {
				mightBeEmpty = false;
			}
		}
	}

	if (failed) {
		console.log(&#39;&#39;);
		console.log(chalk.green(&#39;Please go take a look at the TODOs in these new files, then do an `&#39; + chalk.bold(&#39;appc run&#39;) + &#39;` or `&#39; + chalk.bold(&#39;npm test&#39;) + &#39;` to try out the new capabilities.&#39;));
		console.log(&#39;&#39;);

		process.exit();
	}

	if (mightBeEmpty) {
		console.log(&#39;&#39;);
		console.log(chalk.red(&#39;This connector does not do much of anything at the moment.&#39;));
		console.log(chalk.red(&#39;Why don\&#39;t you take a look at the &quot;&#39; + chalk.underline(&#39;capabilities&#39;) + &#39;&quot; array in:&#39;));
		console.log(chalk.red(path.join(connectorDir, &#39;lib&#39;, &#39;index.js&#39;)));
		console.log(&#39;&#39;);
	}
}

function crawlTemplates(connectorDir, templateDir, currentPath) {
	var lookIn = currentPath ? path.join(templateDir, currentPath) : templateDir,
		copyTo = currentPath ? path.join(connectorDir, currentPath) : connectorDir;

	if (!fs.existsSync(lookIn)) {
		return;
	}
	if (!fs.existsSync(copyTo)) {
		fs.mkdirSync(copyTo);
	}
	var children = fs.readdirSync(lookIn);
	for (var i = 0; i &lt; children.length; i++) {
		var child = children[i];
		if (child[0] === &#39;.&#39;) {
			continue;
		}
		var templateFile = path.join(lookIn, child);
		if (fs.statSync(templateFile).isDirectory()) {
			crawlTemplates(connectorDir, templateDir, currentPath ? path.join(currentPath, child) : child);
		}
		else if (child.slice(-3) === &#39;.js&#39;) {
			var newFile = path.join(copyTo, child),
				relNewFile = currentPath ? path.join(currentPath, child) : child;
			if (!fs.existsSync(newFile)) {

				var newContent = fs.readFileSync(templateFile, &#39;UTF-8&#39;);
				fs.writeFileSync(newFile, newContent);

				var todos = (newContent.match(/TODO/g) || []).length,
					log = chalk.dim(&#39; - &#39;) + chalk.yellow(&#39;Created `&#39; + chalk.underline(relNewFile) + &#39;`&#39;);
				if (todos) {
					log += chalk.dim(&#39; (contains &#39;) + chalk.magenta(todos + &#39; TODOs&#39;) + chalk.dim(&#39;)&#39;);
				}
				console.log(log);
			}
		}
	}
}

function logIfExists(ref) {
	if (fs.existsSync(ref)) {
		console.log(chalk.green(fs.readFileSync(ref, &#39;UTF-8&#39;)));
	}
}
</pre>
</body>
</html>
