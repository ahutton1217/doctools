<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*
 * This code is closed source and Confidential and Proprietary to
 * Appcelerator, Inc. All Rights Reserved.  This code MUST not be
 * modified, copied or otherwise redistributed without express
 * written permission of Appcelerator. This file is licensed as
 * part of the Appcelerator Platform and governed under the terms
 * of the Appcelerator license agreement.
 */

// jscs:disable
<span id='Arrow-Router'>/**
</span> * @class Arrow.Router
 */
// jscs:enable

var _ = require(&#39;lodash&#39;);

// jscs:disable jsDoc
/*
 * Handles routing requests through API Builder Tools.
 * @param impl
 * @param config
 * @param arrow
 * @constructor
 */
function Router(impl, config, arrow) {

	impl &amp;&amp; _.merge(this, impl);

	this.arrow = arrow;
	if (this.enabled === undefined) {
		this.enabled = true;
	}

	// incoming constructor config should overwrite implementation
	this.config = _.merge(impl &amp;&amp; impl.config || {}, config);

	// if we provided a constructor in our impl, use it
	if (this.constructor &amp;&amp; this.constructor !== Router &amp;&amp; !this.constructor.super_) {
		this.constructor.call(this);
		Router.constructor.call(this);
	}

	if (!this.name) {
		throw new Error(&#39;required name missing on Router&#39;);
	}
}
// jscs:enable jsDoc

<span id='Arrow-Router-static-method-extend'>/**
</span> * Returns a constructor function to generate a new Router endpoint.
 * Pass the constructor an Arrow configuration object and Arrow instance.
 * @static
 * @param {Dictionary&lt;Arrow.Router&gt;} impl Implementation object.
 * @returns {Function}
 * @throws {Error} Missing name parameter or not called from a valid Arrow instance.
 */
Router.extend = function classExtend(impl) {
<span id='Arrow-Router-property-'>	/**
</span>	 * Creates a Router.
	 */
	return function RouterConstructor(config, arrow) {
		if (!arrow) {
			throw new Error(&#39;invalid constructor. must be called with arrow instance as 2nd argument&#39;);
		}
		return new Router(impl, config, arrow);
	};
};

<span id='Arrow-Router-method-extend'>/**
</span> * Returns a constructor function to generate a new Router endpoint.
 * Pass the constructor an Arrow configuration object and Arrow instance.
 * @param {Dictionary&lt;Arrow.Router&gt;} impl Implementation object.
 * @returns {Function}
 * @throws {Error} Missing name parameter.
 */
Router.prototype.extend = function instanceExtend(impl) {
	return Router.extend(_.merge(this, impl));
};

<span id='Arrow-Router-method-bind'>/**
</span> * Binds this route to the app instance.
 * @param {Object} app App instance.
 * @throws {Error} Missing app instance.
 */
Router.prototype.bind = function (app) {
	if (!app) { throw new Error(&#39;app required for bind&#39;); }
	var method = (this.method || &#39;GET&#39;).toLowerCase();
	app.logger.debug(&#39;binding route (&#39; + method + &#39;) &#39; + this.path);
	this.route = app[method](this.path, this.getMiddleware());
};

<span id='Arrow-Router-method-remove'>/**
</span> * Removes the route from the Arrow instance.
 * @param {Object} arrow Arrow instance.
 * @param {Function} callback Callback passed an Error object (or null if successful) and the removed route.
 */
Router.prototype.remove = function (arrow, callback) {
	var self = this;
	arrow.routes = _.reject(arrow.routes, function (e) {
		return e === self;
	});
	// remove the routing entry from express
	var array = arrow.app._router.stack;
	for (var c = 0; c &lt; array.length; c++) {
		var entry = array[c];
		if (entry.route &amp;&amp; entry.route.path === this.path) {
			var stack = entry.route.stack;
			for (var i = 0; i &lt; stack.length; i++) {
				if (stack[i].method.toLowerCase() === this.method.toLowerCase()) {
					stack.splice(i, 1);
					break;
				}
			}
			// no more routes, remove it
			if (stack.length === 0) {
				array.splice(c, 1);
			}
			break;
		}
	}
	callback &amp;&amp; callback(null, this);
};

<span id='Arrow-Router-method-reload'>/**
</span> * Reloads the route. Call this function if changes were made to the route.
 * @param {Object} arrow Arrow instance.
 * @param {Function} callback Callback passed an Error object (or null if successful) and the reloaded route.
 */
Router.prototype.reload = function (arrow, callback) {
	if (this.filename) {
		var fs = require(&#39;fs&#39;);
		this.timestamp = fs.statSync(this.filename).mtime;
		var old = this;
		// remove the route
		this.remove(arrow, function () {
			// remove it from the arrow
			arrow.loadRoute(old.filename, function (err, route) {
				callback &amp;&amp; callback(err, old, route);
			});
		});
	} else {
		callback &amp;&amp; callback(null, this);
	}
};

<span id='Arrow-Router-method-getMiddleware'>/**
</span> * Gets the middleware block that provides access to the
 * route&#39;s action implementation.
 * Pass the function returned by this method a request object,
 * response object, and the function to call next.
 * @returns {Function}
 */
Router.prototype.getMiddleware = function getMiddleware() {
	var self = this;
<span id='Arrow-Router-method-fn'>	/**
</span>	 * Handles the middleware request, making sure API Builder Tools&#39; security measures are applied and we are set up for handling
	 * the request.
	 */
	var fn = function routeMiddleware(req, resp, next) {
		return self.arrow.executeSecurityMiddleware(req, resp, function (err) {
			if (err) { return next(err); }
			// if the auth plugin changed the status code, bail
			if (resp.statusCode !== 200) {
				return next();
			}
			try {
				req.logmetadata = false;
				req.params = _.merge(req.params, req._params);
				var action = self.action || self.execute; // allow both
				if (action) {
					if (action.length === 3) {
						var _render = resp.render,
							_rendered = false;
<span id='Arrow-Router-method-render'>						/**
</span>						 * do implicit or explicit handling of next in render
						 */
						resp.render = function (name, args, cb) {
							if (!_rendered) {
								_rendered = true;
								if (arguments.length &gt; 2 &amp;&amp; cb !== next) {
									// we need to render and pass the html back to the cb.
									_render.call(resp, name, args, cb);
								} else {
									// otherwise, we need to render AND send the html.
									_render.call(resp, name, args, function (err, html) {
										if (err) {
											next(err);
										} else {
											if (html) {
												resp.send(html);
											}
											next();
										}
									});
								}
							}
						};
						return action(req, resp, next);
					} else {
						action(req, resp);
						return next();
					}
				} else {
					return next();
				}
			}
			catch (E) {
				next(E);
			}
		});
	};
	fn._name = &#39;router:&#39; + this.name;
	fn.filename = this.filename;
	fn.description = this.description;
	return fn;
};

module.exports = Router;
</pre>
</body>
</html>
