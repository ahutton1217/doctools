<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*
 * This code is closed source and Confidential and Proprietary to
 * Appcelerator, Inc. All Rights Reserved. This code MUST not be
 * modified, copied or otherwise redistributed without express
 * written permission of Appcelerator. This file is licensed as
 * part of the Appcelerator Platform and governed under the terms
 * of the Appcelerator license agreement.
 */
// jscs:disable
<span id='Arrow-Block'>/**
</span> * @class Arrow.Block
 */
// jscs:enable
var _ = require(&#39;lodash&#39;),
	util = require(&#39;util&#39;),
	events = require(&#39;events&#39;),
	async = require(&#39;async&#39;),
	blocks = [],
	BlockClass = new events.EventEmitter();

// jscs:disable jsDoc

util.inherits(Block, events.EventEmitter);

function Block(impl, config, arrow) {

	impl &amp;&amp; _.merge(this, impl);

	this.arrow = arrow;

	// incoming constructor config should overwrite implementation
	this.config = _.merge(impl &amp;&amp; impl.config || {}, config);

	// if we provided a constructor in our impl, use it
	if (this.constructor &amp;&amp; this.constructor !== Block &amp;&amp; !this.constructor.super_) {
		this.constructor.call(this);
		Block.constructor.call(this);
	}

	if (!this.name) {
		throw new Error(&#39;required name missing on Block&#39;);
	}
}

Block.on = function on() {
	BlockClass.on.apply(BlockClass, arguments);
};

Block.removeListener = function removeListener() {
	BlockClass.removeListener.apply(BlockClass, arguments);
};

Block.removeAllListeners = function removeAllListeners() {
	BlockClass.removeAllListeners.apply(BlockClass, arguments);
};

// NOTE: this is internal and only used by the test and should never be called directly
Block.clearBlocks = function clearBlocks() {
	blocks.length = 0;
};

<span id='Arrow-Block-static-method-extend'>/**
</span> * Returns a constructor function to generate a new Block.
 * Pass the constructor an Arrow configuration object and Arrow instance.
 * @static
 * @param {Dictionary&lt;Arrow.Block&gt;} impl Implementation object.
 * @returns {Function}
 * @throws {Error} Missing name parameter or not called from a valid Arrow instance.
 */
Block.extend = function classExtend(impl) {
	return function BlockConstructor(config, arrow) {
		if (!arrow) {
			throw new Error(&#39;invalid constructor. must be called with arrow instance as 2nd argument&#39;);
		}
		return new Block(impl, config, arrow);
	};
};

<span id='Arrow-Block-method-extend'>/**
</span> * Returns a constructor function to generate a new Block.
 * Pass the constructor an Arrow configuration object and Arrow instance.
 * @param {Dictionary&lt;Arrow.Block&gt;} impl Implementation object.
 * @returns {Function}
 * @throws {Error} Missing name parameter or not called from a valid Arrow instance.
 */
Block.prototype.extend = function instanceExtend(impl) {
	return Block.extend(_.merge(this, impl));
};

<span id='Arrow-Block-method-getMiddleware'>/**
</span> * Gets the middleware block that provides access to the
 * block&#39;s execute implementation.
 * Pass the function returned by this method a request object,
 * response object, and the function to call next.
 * @returns {Function}
 */
Block.prototype.getMiddleware = function getMiddleware() {
	var fn = function blockMiddleware(req, resp, next) {
		try {
			var blockFn = this.action || this.execute;
			if (blockFn) {
				if (blockFn.length === 3) {
					blockFn(req, resp, next);
				} else {
					blockFn(req, resp);
					next();
				}
			} else {
				return next();
			}
		}
		catch (E) {
			next(E);
		}
	}.bind(this);
	fn._name = &#39;block:&#39; + this.name;
	fn.filename = this.filename;
	fn.description = this.description;
	return fn;
};

module.exports = Block;
</pre>
</body>
</html>
