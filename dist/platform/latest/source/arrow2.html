<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*
 * This code is closed source and Confidential and Proprietary to
 * Appcelerator, Inc. All Rights Reserved. This code MUST not be
 * modified, copied or otherwise redistributed without express
 * written permission of Appcelerator. This file is licensed as
 * part of the Appcelerator Platform and governed under the terms
 * of the Appcelerator license agreement.
 */

// jscs:disable
<span id='Arrow'>/**
</span> * @class Arrow
 */
	// jscs:enable
exports = module.exports = Arrow;
var consoleLog = console.error.bind(console);
var AppC = require(&#39;arrow-admin&#39;).AppC;
var inProduction;
var pendingRequests = 0;
var lastGCCheck = Date.now();
var stopping = false;
var openSockets = {};

// jscs:disable jsDoc

if (process.env.serverId &amp;&amp; process.env.appid) {
	inProduction = true;
}

// set correct defaults for runtime in production
// must do this before loading the Loader below which loads config files
if (inProduction) {
	// if neither are set, use smart defaults
	if (!process.env.NODE_ENV &amp;&amp; !process.env.APPC_ENV) {
		process.env.NODE_ENV = process.env.APPC_ENV = AppC.isProduction ? &#39;production&#39; : &#39;preproduction&#39;;
	} /* APPC_ENV takes precendence*/ else if (process.env.APPC_ENV) {
		process.env.NODE_ENV = process.env.APPC_ENV;
	} else {
		process.env.APPC_ENV = process.env.NODE_ENV;
	}
}

// set the name of the node process
process.title = &#39;arrow&#39; + (process.env.APPC_WORKER_PID ? (&#39; (node worker #&#39; + process.env.APPC_WORKER_ID + &#39;)&#39;) : &#39;&#39;);

var express = require(&#39;express&#39;),
	_ = require(&#39;lodash&#39;),
	events = require(&#39;events&#39;),
	fs = require(&#39;fs&#39;),
	path = require(&#39;path&#39;),
	util = require(&#39;util&#39;),
	crypto = require(&#39;crypto&#39;),
	async = require(&#39;async&#39;),
	wrench = require(&#39;wrench&#39;),
	cluster = require(&#39;cluster&#39;),
	debug = require(&#39;debug&#39;)(&#39;arrow&#39;),
	pkg = require(&#39;../package.json&#39;),
	Metadata = require(&#39;./metadata&#39;),
	Logger = require(&#39;appc-logger&#39;),
	memwatch,
	Loader = require(&#39;./loader&#39;),
	Response = require(&#39;./response&#39;),
	RequestTx = require(&#39;./request_tx&#39;),
	Middleware = require(&#39;./middleware&#39;),
	Block = require(&#39;./block&#39;),
	Router = require(&#39;./router&#39;),
	FlowManager = require(&#39;arrow-flow&#39;).FlowManager,
	Endpoints = require(&#39;arrow-endpoint&#39;),
	CLI = require(&#39;./cli&#39;),
	API = require(&#39;./api&#39;),
	orm = require(&#39;arrow-orm&#39;),
	uuid = require(&#39;uuid-v4&#39;),
	paths = require(&#39;./paths&#39;),
	requireUncached = require(&#39;require-uncached&#39;),
	pluralize = require(&#39;pluralize&#39;),
	chalk = require(&#39;chalk&#39;),
	Authentication = require(&#39;./authentication&#39;),
	LogManager = require(&#39;./logmanager&#39;),
	bindSwaggerRoutes = require(&#39;./swagger&#39;).bindRoutes,
	pluginUtil = require(&#39;./plugin/util&#39;),
	Connector = orm.Connector,
	Model = orm.Model,
	Collection = orm.Collection,
	Instance = orm.Instance,
	connectors = {},
	globalArrow,
	inGetConnector,
	pendingModels,
	loadedModelDirs = [],
	instantiations = [],
	servers = [];

try {
	memwatch = require(&#39;memwatch-next&#39;);
}
catch (err) {
	// appc-memwatch isn&#39;t installed. Carry on anyway.
}

util.inherits(Arrow, events.EventEmitter);

// allow people to reference the built-in debug module
Arrow.debug = debug;

// merge in orm into our Arrow
for (var key in orm) {
	if (orm.hasOwnProperty(key)) {
		Arrow[key] = orm[key];
		orm[key].Arrow = Arrow;
	}
}

Arrow.API = API;
Arrow.Block = Block;
Arrow.CLI = CLI;
Arrow.Formation = require(&#39;./formatters&#39;);
Arrow.Loader = Loader;
Arrow.Logger = Logger;
Arrow.Metadata = Metadata;
Arrow.Middleware = Middleware;
Arrow.ORM = orm;
Arrow.Router = Router;
Arrow.Version = pkg.version;

function Arrow(config, loadOnly) {
	if (instantiations !== undefined) {
		instantiations.push(this);
	}
	this.config = new Loader(config &amp;&amp; config.dir, null, config);
	this.port = process.env.PORT;
	if (!inProduction &amp;&amp; this.port === undefined) {
		this.port = this.config.port;
		if (this.port === undefined) {
			this.port = 8080;
		}
	}
	if (!this.config.admin) {
		this.config.admin = {};
	}
	this.config.admin.prefix = this.config.admin.prefix || &#39;/arrow&#39;;
	this.config.apiPrefix = this.config.apiPrefix || &#39;/api&#39;;
	this.loadOnly = loadOnly;
	this.inProduction = !!inProduction;
	this.ignoreDuplicateModels = !!this.config.ignoreDuplicateModels;

	if (!globalArrow) {
		globalArrow = this;
		// since the continuation listeners potentially has a ton of listeners on startup
		globalArrow.setMaxListeners(Number.MAX_VALUE);
	}

	if (process.env.APPC_LOG_LEVEL) {
		// change the internal config to use the environment
		this.config.logLevel = process.env.APPC_LOG_LEVEL;
	}
	if (config &amp;&amp; config.overrideLevel) {
		this.config.logLevel = config.overrideLevel;
	}

	// configure the default apikey based on env
	if (!this.config.apikey_preproduction) {
		this.config.apikey_preproduction = this.config.apikey_production || this.config.apikey_development || this.config.apikey;
	}
	if (!this.config.apikey) {
		var key = &#39;apikey_&#39; + this.config.env;
		this.config.apikey = this.config[key];
	} else {
		// set the api key to the same if we only use one
		this.config.apikey_production = this.config.apikey_preproduction = this.config.apikey_development = this.config.apikey;
	}
	// this is the default path (inside if). we use this
	// as a way to be able to load up API Builder Tools but without
	// creating the server infrastructure. this is useful for
	// being able to programatically load models, connectors, etc
	if (!loadOnly) {

		var self = this;
		this.express = express;
		var server = this.app = express();

		var healthCheckAPI = this.config.healthCheckAPI;
		if (healthCheckAPI) {
			try {
				healthCheckAPI = require(path.resolve(process.cwd(), healthCheckAPI));
			}
			catch (E) {
				this.logger.trace(E.stack);
				this.logger.error(&#39;error loading health check plugin&#39;, healthCheckAPI, E);
			}
		}

		// handle any API Runtime Services health checks -- allow the user to specify their own
		// plugin or we&#39;ll provide a basic one that simply returns success if we are reachable
		// and not in shutdown phase
		server.get(&#39;/arrowPing.json&#39;, healthCheckAPI || function (req, resp, next) {
			return resp.json({success: !self.shuttingdown});
		});

		// make sure that the loger is created after the healthcheck API is defined.
		this.logger = createServerLogger(this, server);

		// add graceful shutdown middleware which will send 503 responses to
		// any incoming connection requests while we&#39;re in shutdown mode. any
		// front end load balancer (like API Runtime Services) should correctly
		server.use(function (req, resp, next) {
			if (self.shuttingdown) {
				resp.shouldKeepAlive = false;
				resp.set(&#39;Connection&#39;, &#39;close&#39;);
				resp.set(&#39;Cache-Control&#39;, &#39;no-cache, no-store, max-age=0&#39;);
				resp.set(&#39;Pragma&#39;, &#39;no-cache&#39;);
				resp.status(503);
				resp.end(&#39;Server is shutting down&#39;);
			} else {
				next();
			}
		});

		if (this.inProduction) {
			this.app.enable(&#39;trust proxy&#39;);
		}

		// add the request-id helper
		express.request.getId = function () {
			if (!this._reqid) {
				this._reqid = uuid();
			}
			return this._reqid;
		};

		var baseurl = this.config.baseurl || process.env.ARROWCLOUD_APP_URL || process.env.ARROW_PUBLIC_URL || process.env.NODE_ACS_URL;
		if (this.config.env === &#39;development&#39; &amp;&amp; !this.inProduction) {
			baseurl = &#39;http://localhost:&#39; + this.port;
		}

		if (baseurl === undefined &amp;&amp; this.config.env === &#39;production-eu&#39;) {
			baseurl = &#39;http://localhost:&#39; + this.port;
		}

		addLocals(this, this.app, baseurl);

		// bind a logger to the server itself
		server.logger = this.logger;

		var appPkg = path.join(config &amp;&amp; config.dir || process.cwd(), &#39;package.json&#39;);
		if (fs.existsSync(appPkg)) {
			appPkg = require(appPkg);
			this.logger.info(chalk.blue.bold(&#39;API Builder Tools/&#39; + pkg.version) + &#39; &#39; + chalk.yellow(appPkg.name + &#39;/&#39; + appPkg.version));
		} else {
			appPkg = {};
			// fallback if we can&#39;t find package.json for app
			this.logger.info(chalk.blue.bold(&#39;API Builder Tools/&#39; + pkg.version));
		}
		this.productionNodeVersion = appPkg.engines &amp;&amp; appPkg.engines.node;

		if (this.config.apikey) {
			this.logger.info(&#39;APIKey is:&#39;, chalk.gray(this.config.apikey));
		}

		// if we have a pubsub configuration, enable it for events
		if (this.config.pubsub) {
			this.definePubSub(appPkg);
		}

		var sessionConfig = this.config &amp;&amp; this.config.session || {};

		server.use(function (req, resp, next) {
			req.pendingReqCount = ++pendingRequests;
			req.server = self;
			if (!self.config.disableServerBanner) {
				resp.set(&#39;Server&#39;, &#39;API Builder Tools/&#39; + pkg.version);
			}
			resp.set(&#39;Request-Id&#39;, req.getId());
			resp.locals[&#39;request-id&#39;] = req.getId();
			req.logger = resp.logger = req.log = req.log || self.logger;
			next();
		});

		// this should always be at the top before anything else but after setting up the logger
		server.use(createRequestTransaction(this.config));

		// create the generic express middleware
		this.middleware = new Middleware(server, this.config.dir, sessionConfig, this.config);

		server.on(&#39;after&#39;, endRequestTransaction.bind(server));

		// add CORs headers
		server.use(function (req, resp, next) {
			if (req.method === &#39;OPTIONS&#39;) {
				var apis = API.getAPIsForPath(req.path);

				if (apis) {
					var options = _.unique(apis.map(function (api) {
						return api.method.toUpperCase();
					})).join(&#39;,&#39;);
					var checkMethod = req.headers[&#39;access-control-request-method&#39;];
					if (checkMethod &amp;&amp; options.indexOf(checkMethod.toUpperCase()) &lt; 0) {
						// to deny, just send 200 without CORS headers
						return resp.status(200).end();
					}
					resp.setHeader(&#39;Allow&#39;, options);
					addCORsHeaders(self.config, req, resp);
					return resp.status(200).end();
				} else if (req.path === self.config.admin.prefix + &#39;/testapi&#39; || req.path === self.config.admin.prefix + &#39;/metadata/logs&#39;) {
					// CORS should be enabled for our testapi and logs XHR
					addCORsHeaders(self.config, req, resp);
				}
			} else if (req.headers.origin) {
				// CORS
				addCORsHeaders(self.config, req, resp);
			}
			next();
		});

		// load up admin if enabled
		this.config.admin &amp;&amp; this.config.admin.enabled &amp;&amp; (this.admin = new (require(&#39;./admin&#39;))(this));

		// create the default authentication strategy
		try {
			this.authstrategy = new Authentication(this);
		}
		catch (E) {
			this.logger.fatal(&#39;Error attempting to configure API authentication. &#39; + E.message || E);
		}

		this.logger.trace(&#39;creating Arrow server instance on port %d&#39;, this.port);
	} else {
		this.logger = Logger.createLogger({name: pkg.name, useConsole: true, level: this.config.logLevel});
		this.pkg = pkg;
	}

	if (process.env.APPC_DUMP_ENV) {
		this.logger.trace(process.env);
	}

	// pass the config to components but remove some parts
	this.objConfig = _.pick(this.config, &#39;name&#39;, &#39;port&#39;, &#39;admin&#39;, &#39;session&#39;, &#39;apikey&#39;, &#39;apikey_production&#39;, &#39;apikey_development&#39;);

	this.flowManager = new FlowManager(this.config, this.logger);
	this.models = {};
	this.apis = [];
	this.blocks = {};
	this.routes = [];
	this.codeblocks = {};
	this.endpoints = {};
	this.addCORsHeaders = addCORsHeaders;

	if (!loadOnly) {
		this.on(&#39;reload&#39;, this.reload);
	}

	// start loading our server
	process.nextTick(this.load.bind(this));
}

function addLocals(server, app, baseurl) {
	// record our base url for the platform and our external url
	app.locals.appc_platform_url = server.platformurl = AppC.baseurl;
	app.locals.appc_external_url = server.baseurl = baseurl;
	app.locals.appc_external_admin_url = server.adminurl = app.locals.appc_external_url + server.config.admin.prefix;
	app.locals.appc_external_create_url = server.createurl = app.locals.appc_external_url + server.config.admin.createprefix;
	app.locals.appc_external_apidoc_url = server.apidocurl = app.locals.appc_external_url + (server.config.admin &amp;&amp; server.config.admin.apiDocPrefix || &#39;/apidocs&#39;);
	app.locals.appc_env = process.env.APPC_ENV || process.env.NODE_ENV;
	app.locals.appc_registry_url = process.env.APPC_REGISTRY_SERVER || AppC.registryurl;
	server.logger.trace(&#39;setting app locals&#39;, app.locals);
}

// default headers that are allowed
// change them by setting property in config
//
// cors: {
//  safeHeaders: [&#39;origin&#39;]
// }
//
//
const DEFAULT_SAFE_HEADERS = [
	&#39;x-requested-with&#39;,
	&#39;request-id&#39;,
	&#39;response-time&#39;,
	&#39;accept&#39;,
	&#39;origin&#39;,
	&#39;content-type&#39;,
	&#39;authorization&#39;,
	&#39;x-titanium-id&#39;,
	&#39;x-native-id&#39;
];

function addCORsHeaders(config, req, resp) {
	var corsConfig = config.cors || {},
		checkOrigin = corsConfig[&#39;Access-Control-Allow-Origin&#39;] || &#39;*&#39;,
		allowMethods = corsConfig[&#39;Access-Control-Allow-Methods&#39;];
	if (req.headers.origin &amp;&amp; req.headers.host &amp;&amp; req.headers.origin.indexOf(req.headers.host) &gt; 0) {
		if (checkOrigin === &#39;*&#39; || checkOrigin === req.headers.origin) {
			resp.setHeader(&#39;Access-Control-Allow-Origin&#39;, req.headers.origin);
		} else {
			// deny it
			return;
		}
	} else {
		resp.setHeader(&#39;Access-Control-Allow-Origin&#39;, checkOrigin);
	}

	if (allowMethods) {
		resp.setHeader(&#39;Access-Control-Allow-Methods&#39;, typeof allowMethods === &#39;object&#39; ? allowMethods.join(&#39;, &#39;) : allowMethods);
	}

	if (&#39;access-control-request-headers&#39; in req.headers) {
		var safeHeaders = corsConfig.safeHeaders || DEFAULT_SAFE_HEADERS;
		var wantHeaders = _.compact(req.headers[&#39;access-control-request-headers&#39;].split(&#39;,&#39;).map(function (h) {
			h = h.trim();
			if (safeHeaders.indexOf(h) !== -1) {
				return h;
			}
		})).join(&#39;, &#39;);
		resp.setHeader(&#39;Access-Control-Expose-Headers&#39;, wantHeaders);
		resp.setHeader(&#39;Access-Control-Allow-Headers&#39;, wantHeaders);
		resp.setHeader(&#39;Access-Control-Allow-Credentials&#39;, &#39;true&#39;);
	}
}

<span id='Arrow-method-getMiddleware'>/**
</span> * Returns the middleware instance containing the Express app instance.
 * @returns {Arrow.Middleware}
 */
Arrow.prototype.getMiddleware = function () {
	return this.middleware;
};

<span id='Arrow-method-trackInstantiations'>/**
</span> * Tracks all instantiations.
 */
Arrow.trackInstantiations = function () {
	instantiations = [];
};

/*
 * used for testing only
 *
 * @private
 */
Arrow.resetGlobal = function () {
	if (instantiations !== undefined) {
		instantiations.forEach(function (arrow) {
			if (arrow.logmanager) {
				arrow.logmanager.stop();
			}
			if (arrow.logger &amp;&amp; arrow.logger.requestLogger &amp;&amp; arrow.logger.requestLogger.streams) {
				arrow.logger.requestLogger.streams.forEach(function (f) {
					f.stream.end();
				});
			}
		});
		instantiations = [];
	}
	Arrow.ORM.MemoryConnector.resetPrimaryKeys();
	connectors = {};
	loadedModelDirs = [];
	globalArrow = null;
	pendingRequests = 0;
};

<span id='Arrow-method-getGlobal'>/**
</span> * Gets a reference to the first instantiated Arrow server.
 * @returns {Arrow}
 */
Arrow.getGlobal = function () {
	return globalArrow;
};

/*
 * create the logger
 */
function createServerLogger(arrow, server) {
	var logging = arrow.config.logging || {};
	var appPkg = path.join(arrow.config &amp;&amp; arrow.config.dir || process.cwd(), &#39;package.json&#39;);
	var name = &#39;arrow-app&#39;; // default name is arrow-app
	if (logging.adiLogging &amp;&amp; fs.existsSync(appPkg)) {
		appPkg = require(appPkg);
		name = appPkg.name || name;
	}
	// use a restify logger if transaction logging is on. it contains a console logger
	// too...
	// API-689 -- disable in production for now
	if (arrow.inProduction) {
		logging.transactionLogEnabled = false;
	}
	if (cluster.isWorker) {
		// we set the request logger to be unique so that each cluster worker will
		// write to a different file
		logging.requestsLogFilename = &#39;request-cluster-&#39; + cluster.worker.id + &#39;.log&#39;;
		arrow.config.logging = logging;
	}
	// create the restify logger
	var logger = Logger.createRestifyLogger(server, {
		afterEvent: &#39;txdone&#39;,
		level: arrow.config.logLevel,
		logs: logging.directory,
		requestsLogFilename: logging.requestsLogFilename,
		logSingleRequest: logging.transactionLogEnabled || logging.transactionLogEnabled === undefined,
		adiLogging: logging.adiLogging,
		name: name,
		adiPathFilter: [arrow.config.apiPrefix]
	});
	// only setup the log manager if transaction logging is enabled and we&#39;re in production
	if (arrow.inProduction || logging.processRemoteLogsInDev) {
		if (!arrow.inProduction &amp;&amp; logging.processRemoteLogsInDev) {
			// write out test log config
			var logConfigFn = path.join(arrow.config.dir, &#39;conf&#39;, &#39;deploy.json&#39;),
				logConfig = {
					logserver: &#39;http://127.0.0.1:8999&#39;,
					org_id: process.env.APPC_SESSION_ORGID,
					username: process.env.APPC_SESSION_USERNAME,
					name: pkg.name,
					version: pkg.version
				};
			fs.writeFileSync(logConfigFn, JSON.stringify(logConfig));
		}
		arrow.logmanager = new LogManager(arrow, logger);
	}
	return logger;
}

/*
 * start a connector and call next when completed
 */
function startConnector(instance, connector, next) {
	if (connector.connect &amp;&amp; !instance.loadOnly &amp;&amp; !connector.started) {
		// if the connector is disabled, don&#39;t start it
		if (connector.enabled === false || (connector.config &amp;&amp; connector.config.enabled === false)) {
			if (!connector.enableWarning) {
				// only warn once
				instance.logger.info(chalk.green(&#39;connector/&#39; + connector.name) + &#39; is disabled in config. will not start it and it won\&#39;t be available&#39;);
			}
			connector.enabled = false;
			connector.enableWarning = true;
			return next();
		}
		instance.logger.info(&#39;starting &#39; + chalk.green(&#39;connector/&#39; + connector.name + (connector.version ? (&#39;@&#39; + connector.version) : &#39;&#39;)));
		connector.connect(function (err) {
			if (err) {
				err = new Error(&#39;Error loading connector/&#39; + connector.name + &#39;. &#39; + (err.message || err));
				return next(err);
			}
			connector.started = true;
			connector.enabled = true;
			instance.logger.info(&#39;started &#39; + chalk.green(&#39;connector/&#39; + connector.name));
			next &amp;&amp; next();
		});
	} else {
		next &amp;&amp; next();
	}
}

<span id='Arrow-method-getComponentDir'>/**
</span> * Returns the full path of the component directory.
 * @param {String} type Component type, that is, `api`, `block`, `model` or `route`.
 * @param {Boolean} nmd Set to `true` if using a node module.
 * @returns String
 */
Arrow.prototype.getComponentDir = function getComponentDir(type, nmd) {
	if (type === &#39;route&#39;) {
		// these live in a little bit of a different location
		return path.resolve(path.join(this.config.dir || process.cwd(), &#39;web&#39;, &#39;routes&#39;));
	}
	return path.resolve(path.join(this.config.dir || process.cwd(), (nmd ? &#39;node_modules/&#39; : &#39;&#39;) + type + &#39;s&#39;));
};

<span id='Arrow-method-definePubSub'>/**
</span> * Prepares appc-pubsub for usage within Arrow. Warns the user if it is not installed locally to their project, or not
 * configured properly.
 */
Arrow.prototype.definePubSub = function (appPkg) {
	var self = this;
	if (!this.config.pubsub.key || !this.config.pubsub.secret) {
		self.logger.error(&#39;appc-pubsub is defined in your configuration, but not correctly! Please specify your pubsub key and secret.&#39;);
		return;
	}
	var PubSubClient;
	try {
		PubSubClient = require(&#39;appc-pubsub&#39;);
	}
	catch (E) {
		self.logger.error(&#39;appc-pubsub is configured, but not installed! Please make sure you install it: `npm install --save appc-pubsub`.&#39;, E, E.stack);
		return;
	}
	var options = _.merge({}, this.config.pubsub);
	try {
		options.newrelic = require(&#39;newrelic&#39;);
	}
	catch (E) {
		self.logger.trace(&#39;newrelic is not installed; if you want it to run, please `npm install --save newrelic`.&#39;);
		// this is OK, just means we don&#39;t have it
	}
	this.pubsub = new PubSubClient(options);
	this.pubsub.on(&#39;error&#39;, function (err) {
		self.logger.error(&#39;pubsub error&#39;, err, err.stack);
	});
	this.pubsub.on(&#39;unauthorized&#39;, function (err) {
		self.logger.error(&#39;pubsub client is unauthorized. check your key and secret in your configuration to ensure these values are correct.&#39;);
	});
	this.postServerEvent = function (name, immediate) {
		self.pubsub.publish(name, {
			url: process.env.NODE_ACS_URL,
			name: appPkg.name,
			version: appPkg.version,
			appid: process.env.appid,
			serverId: process.env.serverId,
			env: self.config.env,
			username: process.env.APPC_SESSION_USERNAME,
			org_id: process.env.APPC_SESSION_ORGID,
			node_version: process.version,
			arrow_version: pkg.version
		}, immediate);
	};
	this.on(&#39;started&#39;, function () {
		self.postServerEvent(&#39;com.appcelerator.server.started&#39;);
	});
	this.on(&#39;stopping&#39;, function () {
		self.postServerEvent(&#39;com.appcelerator.server.stopped&#39;, true);
	});
	this.on(&#39;stopped&#39;, function () {
		setTimeout(self.pubsub.close.bind(self.pubsub), 500);
	});
};

<span id='Arrow-method-loadApi'>/**
</span> * Loads an API from an API file. The file must exist and be a valid API. No error checking is performed.
 * @param {String} fn Filename of the API.
 * @param {Function} [cb] Callback passed an Error object (or null if successful), the API instance, and the API class.
 */
Arrow.prototype.loadApi = function loadAPI(fn, cb) {
	this.logger.debug(&#39;attempting to load API&#39;, fn);
	var APIClass = paths.requireComponent(fn, true);
	if (!APIClass) {
		this.logger.trace(APIClass);
		throw new Error(&#39;Error loading api at &#39; + fn);
	}
	if (!_.isFunction(APIClass)) {
		this.logger.trace(APIClass);
		throw new Error(&#39;Error loading api at &#39; + fn + &#39;. this module did not export a Class&#39;);
	}
	var api = new APIClass(this.objConfig, this, fn);
	this.apis.push(api);
	this.triggerReloadedIfRequired(false, [{fn: this.app}]);
	cb &amp;&amp; cb(null, api, APIClass);
};

<span id='Arrow-method-loadModel'>/**
</span> * Loads a Model from a Model file. The file must exist and be a valid Model. No error checking is performed.
 * @param {String} fn Filename of the Model.
 * @param {Function} [cb] Callback passed an Error object (or null if successful) and the Model class.
 */
Arrow.prototype.loadModel = function loadModel(fn, cb) {
	this.logger.debug(&#39;attempting to load model&#39;, fn);
	var Model = paths.requireComponent(fn, true);
	if (!Model) {
		this.logger.trace(Model);
		throw new Error(&#39;Error loading model at &#39; + fn);
	}
	if (!_.isObject(Model)) {
		this.logger.trace(Model);
		throw new Error(&#39;Error loading model at &#39; + fn + &#39;. this module did not load properly&#39;);
	}
	if (!_.isFunction(Model.create) &amp;&amp; !Model.loadingModels) {
		this.logger.trace(Model);
		throw new Error(&#39;Error loading model at &#39; + fn + &#39;. this module did not export a Class&#39;);
	}
	// if we don&#39;t provide a connector, attempt to get the connector global default the config
	// this makes it nice since i can simply put my default in the config and i don&#39;t need to specify
	// on each and every model
	Model.connector = Model.connector || this.config.defaultConnector;
	Model.name &amp;&amp; (this.models[Model.name] = Model);
	Model.filename = fn;
	if (!Model.generated) {
		Model.timestamp = fs.statSync(fn).mtime;
	}
	this.triggerReloadedIfRequired(false, [{fn: Model}]);
	cb &amp;&amp; cb(null, Model);
};

<span id='Arrow-method-loadBlock'>/**
</span> * Loads a Block from a Block file. The file must exist and be a valid Block. No error checking is performed.
 * @param {String} fn Filename of the Block.
 * @param {Function} [cb] Callback passed an Error object (or null if successful) and the Block class.
 */
Arrow.prototype.loadBlock = function loadBlock(fn, cb) {
	this.logger.debug(&#39;attempting to load block&#39;, fn);
	var Block = paths.requireComponent(fn, true);
	if (!Block) {
		this.logger.trace(Block);
		throw new Error(&#39;Error loading block at &#39; + fn);
	}
	if (!_.isFunction(Block)) {
		this.logger.trace(Block);
		throw new Error(&#39;Error loading block at &#39; + fn + &#39;. this module did not export a Class&#39;);
	}
	var block = new Block(this.objConfig, this);
	this.blocks[block.name] = block;
	Block.filename = block.filename = fn;
	Block.timestamp = block.timetsamp = fs.statSync(fn).mtime;
	this.triggerReloadedIfRequired(false, [{fn: block}]);
	cb &amp;&amp; cb(null, Block);
};

<span id='Arrow-method-loadFlow'>/**
</span> * Loads a Flow from a flow file. The file must exist and be a valid Flow.
 * @param {String} fn Filename of the flow.
 * @param {Function} [cb] Callback passed an Error object (or null if successful) and the Flow class.
 */
Arrow.prototype.loadFlow = function loadFlow(fn, cb) {
	this.logger.debug(&#39;attempting to load flow&#39;, fn);
	return this.flowManager.load(fn).then(
		function (flow) {
			cb &amp;&amp; cb(null, flow);
		}.bind(this),
		function (err) {
			this.logger.error(err);
			this.logger.error(&#39;Error loading flow at &#39; + fn);
			cb &amp;&amp; cb(err);
		}.bind(this));
};

<span id='Arrow-method-loadEndpoint'>/**
</span> * Loads an endpoint from a file.
 * @param  {string} fn [path to file]
 * @param  {Function} cb [callback to for error handle]
 */
Arrow.prototype.loadEndpoint = function loadEndpoint(fn, cb) {
	this.logger.debug(&#39;attempting to load endpoint&#39;, fn);
	return Endpoints.load(fn, this.getFlows()).then(
		function (endpoint) {
			var endpointName = path.basename(fn, &#39;.json&#39;);
			this.endpoints[endpointName] = endpoint;
			cb &amp;&amp; cb(null, endpoint);
		}.bind(this),
		function (err) {
			var error = &#39;Error loading endpoint at &#39; + fn;
			// err can contain .errors or is an exception
			var errors = [error];
			if (err.errors) {
				err.errors.forEach(function (e) {
					errors.push(JSON.stringify(e));
				});
			} else {
				errors.push((err + &#39;&#39;).replace(/^Error:\s+/, &#39;; &#39;));
			}
			var msg = errors.join(&#39;&#39;).trim();
			this.logger.error(msg);
			cb &amp;&amp; cb(msg);
		}.bind(this));
};

<span id='Arrow-method-loadRoute'>/**
</span> * Loads a Route from a Route file. The file must exist and be a valid Route. No error checking is performed.
 * @param {String} fn Filename of the Route.
 * @param {Function} [cb] Callback passed an Error object (or null if successful) and the Route class.
 */
Arrow.prototype.loadRoute = function loadRoute(fn, cb) {
	this.logger.debug(&#39;attempting to load route&#39;, fn);
	var Router = paths.requireComponent(fn, true);
	if (!Router) {
		this.logger.trace(Router);
		throw new Error(&#39;Error loading route at &#39; + fn);
	}
	if (!_.isFunction(Router)) {
		this.logger.trace(Router);
		throw new Error(&#39;Error loading route at &#39; + fn + &#39;. this module did not export a Class&#39;);
	}
	var route = new Router(this.objConfig, this);
	this.routes.push(route);
	Router.filename = route.filename = fn;
	Router.timestamp = route.timestamp = fs.statSync(fn).mtime;
	this.triggerReloadedIfRequired(false, [{fn: route}]);
	cb &amp;&amp; cb(null, Router);
};

<span id='Arrow-method-loadConnector'>/**
</span> * Loads a Connector from a Connector file. The file must exist and be a valid Connector. No error checking is performed.
 * @param {String} fn Filename of the Connector.
 * @param {Function} [cb] Callback passed an Error object (or null if successful) and the Connector class.
 */
Arrow.prototype.loadConnector = function loadConnector(fn, cb) {
	this.logger.debug(&#39;attempting to load connector&#39;, fn);
	var Connector = paths.requireComponent(fn, true);
	if (!Connector) {
		this.logger.trace(Connector);
		throw new Error(&#39;Error loading connector at &#39; + fn);
	}
	if (!_.isObject(Connector)) {
		this.logger.trace(Connector);
		throw new Error(&#39;Error loading connector at &#39; + fn + &#39;. this module did not export an object&#39;);
	}
	if (!_.isObject(Connector.create)) {
		this.logger.trace(Connector);
		throw new Error(&#39;Error loading connector at &#39; + fn + &#39;. this module did not export a Class function&#39;);
	}
	var connector;
	if (!Connector.name &amp;&amp; Connector.create) {
		if (Connector.filename) {
			connector = this.getConnector(Connector.filename.split(path.sep).pop());
		}
	} else {
		connector = this.getConnector(Connector.name);
	}
	if (connector) {
		connector.filename = Connector.filename = fn;
		startConnector(this, connector, cb);
		this.logger.debug(&#39;loaded connector&#39;, fn);
	} else {
		cb();
	}
};

<span id='Arrow-method-loadCodeblock'>/**
</span> * Loads a Codeblock from a Codeblock file. The file must exist and be a valid Codeblock. No error checking is performed.
 * @param {String} fn Filename of the Codeblock.
 * @param {Function} [cb] Callback passed an Error object (or null if successful) and the Codeblock class.
 */
Arrow.prototype.loadCodeblock = function loadCodeblock(fn, cb) {
	this.logger.debug(&#39;attempting to load codeblock&#39;, fn);
	// get the metadata file and do some basic checks
	var meta, msg;
	try {
		meta = requireUncached(fn);
	} catch (e) {
		this.logger.error(e);
		throw new Error(&#39;Error parsing codeblock &#39; + fn);
	}

	if (!meta) {
		msg = &#39;Error loading codeblock metadata at &#39; + fn;
	} else if (!meta.name) {
		msg = &#39;Error loading codeblock at &#39; + fn + &#39;. \&#39;name\&#39; missing&#39;;
	} else if (meta.name in this.codeblocks) {
		msg = &#39;Error loading codeblock at &#39; + fn + &#39;. \&#39;name\&#39; duplicate&#39;;
	} else if (!meta.path) {
		msg = &#39;Error loading codeblock at &#39; + fn + &#39;. \&#39;path\&#39; missing&#39;;
	}
	if (msg) {
		this.logger.error(msg);
		cb &amp;&amp; cb(msg);
		return;
	}

	// all checks pass. Read the codeblock and save it in the instance
	// get codeblock function file
	var absPath = path.resolve(path.dirname(fn), meta.path);
	try {
		meta.action = requireUncached(absPath);
	}
	catch (ex) {
		msg = &#39;Error loading codeblock at &#39; + fn + &#39;. &#39; + ex;
		this.logger.error(msg);
		cb &amp;&amp; cb(msg);
		return;
	}
	if (typeof (meta.action) !== &#39;function&#39;) {
		msg = &#39;Error loading codeblock at &#39; + fn + &#39;. module is not a function&#39;;
		this.logger.error(msg);
		cb &amp;&amp; cb(msg);
		return;
	}

	this.codeblocks[meta.name] = meta;
	//this.triggerReloadedIfRequired(false, [{fn: fn}]);
	cb &amp;&amp; cb(null, meta);
};

/*
 * internally used to trigger a reloaded event if necessary
 */
Arrow.prototype.triggerReloadedIfRequired = function triggerReloadedIfRequired(force, obj, err) {
	if (!stopping &amp;&amp; (force || this.loaded) &amp;&amp; !this.pendingReload) {
		this.logger.debug(&#39;reloaded&#39;, obj);
		this.emit(&#39;reloaded&#39;, obj &amp;&amp; Array.isArray(obj) ? obj : [obj], err);
	}
};

<span id='Arrow-method-loadComponents'>/**
</span> * Loads all project components.
 * @param {Function} callback Callback to execute after loading each component. Passed an Error object if any.
 * @param {Boolean} skipConnectors Set to `true` to not load Connectors.
 */
Arrow.prototype.loadComponents = function loadComponents(callback, skipConnectors) {
	var instance = this;
	var tasks = [];

	// load crud model nodes
	tasks.push(function (cb) {
		var modelNodes = require(&#39;arrow-flow-invoke&#39;);
		Object.keys(modelNodes).forEach(function (action) {
			instance.logger.debug(&#39;Loading node: &#39; + action);
			instance.flowManager.registerNode(action, modelNodes[action].bind(null, instance));
		});
		cb();
	});

	// make sure we first load any connectors specified in the configuration
	// so that we can setup the aliases correctly
	var allConnectors = this.config &amp;&amp; this.config.connectors;
	for (var name in allConnectors) {
		if (allConnectors.hasOwnProperty(name)) {
			var loadedConnector = instance.getConnector(name, false);
			if (!loadedConnector) {
				this.logger.error(&#39;Couldn\&#39;t find connector named: &#39; + name);
				delete allConnectors[name];
			} else {
				(function (loadedConnector) {
					tasks.push(function (cb) {
						startConnector(instance, loadedConnector, cb);
					});
				})(loadedConnector);
			}
		}
	}

	// load connectors, models, blocks, apis, and then routes from directories (in that order)
	// first using the node_modules (the true) and then
	// using the cwd/&lt;type&gt; (the false)
	[&#39;connector&#39;, &#39;model&#39;, &#39;block&#39;, &#39;api&#39;, &#39;route&#39;, &#39;codeblock&#39; , &#39;flow&#39;, &#39;endpoint&#39;].forEach(function (type) {
		if (skipConnectors &amp;&amp; type === &#39;connector&#39;) { return; }
		var typeName = type.charAt(0).toUpperCase() + type.substring(1),
			mn = &#39;load&#39; + typeName,
			loadFn = instance[mn].bind(instance);
		// set a flag that we&#39;re loading
		tasks.push(function (cb) {
			instance[&#39;loading&#39; + typeName + &#39;s&#39;] = true;
			cb();
		});
		// look inside project directories
		iterateComponentDir(instance, type, true, function (fn) {
			tasks.push(function (cb) {
				try {
					loadFn(fn, cb);
				}
				catch (E) {
					cb(E);
				}
			});
		});
		// then look inside node_modules
		iterateComponentDir(instance, type, false, function (fn) {
			tasks.push(function (cb) {
				try {
					loadFn(fn, cb);
				}
				catch (E) {
					cb(E);
				}
			});
		});
		tasks.push(function (cb) {
			// delete our flag
			delete instance[&#39;loading&#39; + typeName + &#39;s&#39;];
			// fire an event that we&#39;re done loading in case
			// we have someone listening for pending models to finish before continuing
			instance.emit(&#39;loaded&#39; + typeName + &#39;s&#39;);
			cb();
		});
	});

	async.series(tasks, callback);
};

/*
 * called internally to start loading server. when you call start, it will wait until the
 * loaded event is fired
 */
Arrow.prototype.load = function load(callback) {
	this.loadComponents(function (err) {
		if (!err) {
			//indicate we&#39;ve started and emit loading event
			this.loaded = true;
			this.emit(&#39;loaded&#39;);
		} else if (callback) {
			callback(err);
		} else {
			this.emit(&#39;error&#39;, err);
		}
	}.bind(this));
};

/*
 * utility function to iterate a component directory and for each component found, call
 * the foundCallback function will the parameter of the path to the component
 */
function iterateComponentDir(instance, type, useNodeModuleDir, foundCallback) {
	var dir = instance.getComponentDir(type, useNodeModuleDir);
	instance.logger.trace(&#39;iterateComponentDir&#39;, type, dir);
	if (fs.existsSync(dir)) {
		if (type === &#39;model&#39;) {
			try {
				var appcJSON = require(dir + &#39;/../appc.json&#39;);
				if (appcJSON &amp;&amp; appcJSON.type === &#39;connector&#39;) {
					instance.logger.trace(&#39;skipping iterateComponentDir for &#39; + appcJSON.type, type, dir);
					return;
				}
			}
			catch (e) {
			}
			if (loadedModelDirs.indexOf(dir) &gt;= 0) {
				instance.logger.trace(&#39;iterateComponentDir already read&#39;, type, dir);
				return;
			}
			loadedModelDirs.push(dir);
		}

		// if node_modules or a connector, we load not the individual files but the directory as module
		var files;
		if (useNodeModuleDir) {
			var names = fs.readdirSync(dir);
			names.forEach(function nameIterator(name) {
				var ndir = path.join(dir, name),
					pkg = path.join(ndir, &#39;package.json&#39;);
				if (fs.existsSync(pkg)) {
					foundCallback(ndir);
				} else {
					instance.logger.trace(&#39;iterateComponentDir - no package json at&#39;, pkg);
				}
			});
		} else if (type === &#39;connector&#39;) {
			var pkg = path.join(dir, &#39;package.json&#39;);
			if (fs.existsSync(pkg)) {
				foundCallback(dir);
			} else {
				instance.logger.trace(&#39;iterateComponentDir - no package json at&#39;, pkg);
			}
		} else if (type === &#39;codeblock&#39; || type === &#39;flow&#39; || type === &#39;endpoint&#39;) {
			var jsonfileRE = /^((?!_))(.*)?\.json$/;
			wrench.readdirSyncRecursive(dir).forEach(function fileIterator(file) {
				if (jsonfileRE.test(path.basename(file))) {
					var fn = path.join(dir, file);
					foundCallback(fn);
				} else {
					instance.logger.trace(&#39;iterateComponentDir - skipping...&#39;, file);
				}
			});
		} else {
			var jsfileRE = /^((?!_))(.*)?\.js$/;
			wrench.readdirSyncRecursive(dir).forEach(function fileIterator(file) {
				if (jsfileRE.test(path.basename(file))) {
					var fn = path.join(dir, file);
					foundCallback(fn);
				} else {
					instance.logger.trace(&#39;iterateComponentDir - skipping...&#39;, file);
				}
			});
		}
	} else {
		instance.logger.trace(&#39;iterateComponentDir not found&#39;, type, dir);
	}
}

<span id='Arrow-method-get'>/**
</span> * Returns a configuration value for the key (or a provided default value if not found).
 * @param {String} key Key to retrieve.
 * @param {Any} def Default value to return if the key cannot be found.
 */
Arrow.prototype.get = function get(key, def) {
	return this.config[key] || def;
};

/*
 * handle the authentication flow for both sync and async implementations
 */
function executeAuth(authstrategy, req, resp, next) {
	if (authstrategy.validateRequest.length &lt; 3) {
		// this is a synchoronous interface for simplicity
		try {
			var passed = authstrategy.validateRequest(req, resp);
			next(null, passed);
		}
		catch (E) {
			return next(E);
		}
	} else {
		// this is asynchronous
		authstrategy.validateRequest(req, resp, next);
	}
}

/*
 * returns true if this request looks like it&#39;s from the browser and accepts
 * HTML as response
 */
function isBrowserClient(req) {
	return (req.headers &amp;&amp;
	req.headers.accept &amp;&amp;
	req.headers.accept.indexOf(&#39;/html&#39;) &gt; 0 &amp;&amp;
	req.headers[&#39;user-agent&#39;] &amp;&amp;
	/Mozilla|Safari|Chrome|WebKit|Gecko|MSIE/i.test(req.headers[&#39;user-agent&#39;]));
}

<span id='Arrow-method-isModelDuplicate'>/**
</span> * returns false if the model name passed in does not exist.
 * It handles the fatal error if the model does exist.
 *
 * At the moment it returns true, but it should stop the server
 */
function isModelDuplicate(modelName) {
	if (globalArrow &amp;&amp; (modelName in globalArrow.models)) {
		if (globalArrow.ignoreDuplicateModels) {
			return false;
		}
		// Model already exists!
		throw new Error(&#39;Model name: &#39; + modelName + &#39; exists in multiple places&#39;);
	} else {
		return false;
	}
}

<span id='Arrow-method-executeSecurityMiddleware'>/**
</span> * Creates and executes a security middleware call, which authenticates the request.
 * @param {Object} req Request object.
 * @param {Object} resp Response object.
 * @param {Function} next Next function to call.
 */
Arrow.prototype.executeSecurityMiddleware = function executeSecurityMiddleware(req, resp, next) {

	// allow plugins to turn it off
	if (req.skipSecurityCheck) {
		return next();
	}

	// old server plugin. you could specify a authentication function
	// and we would call that. keep this in place for existing apps
	if (this.authentication) {
		if (this.admin &amp;&amp; req.url.indexOf(this.admin.prefix) === 0) {
			return next();
		}
		return this.authorization(req, resp, next);
	}

	// we are using the newer authentication strategy plugin framework
	if (this.authstrategy.matchURL(req)) {
		return executeAuth(this.authstrategy, req, resp, function (err, passed, result) {
			if (!passed || err || result) {
				// if a browser, serve HTML to make it a little more friendly for the user
				if (isBrowserClient(req)) {
					resp.status(401);
					resp.setHeader(&#39;Content-Type&#39;, &#39;text/html&#39;);
					// allow a custom error page if configured, otherwise, use our built-in
					var customPage = req.server.config.admin.customHTMLErrorPage &amp;&amp;
						fs.existsSync(req.server.config.admin.customHTMLErrorPage) &amp;&amp;
						req.server.config.admin.customHTMLErrorPage ||
						path.join(__dirname, &#39;templates&#39;, &#39;401.html&#39;);
					var buf = fs.readFileSync(customPage).toString();
					var ejs = require(&#39;ejs&#39;);
					var hash = Date.now();
					buf = ejs.render(buf, {prefix: req.server.config.admin.prefix, githash: hash});
					resp.write(buf);
					resp.end();
				} else {
					// otherwise, this is an API
					resp.status(err &amp;&amp; err.statusCode || 401);
					resp.json(result || {
							id: err &amp;&amp; err.id || &#39;com.appcelerator.api.unauthorized&#39;,
							message: err &amp;&amp; err.message || &#39;Unauthorized&#39;,
							success: false
						});
				}
				return next(false);
			}
			next();
		});
	} else {
		next();
	}
};

/*
 * calls callback with true if available, false if not
 */
function isPortAvailable(port, cb, tries) {
	// if we are using PORT passed in from API Runtime Services -or-
	// if we&#39;re running in a cluster worker, just continue
	if (inProduction || cluster.isWorker) {
		return cb(true);
	}
	tries = (tries || 0) + 1;
	var net = require(&#39;net&#39;),
		server = net.createServer();
	server.listen(port, function (err) {
		if (err) { return cb(err); }
		var newcb;
		if (port === 0) {
			// pick a random port when 0 is used
			// we need to increment in user land and then verify again (below)
			port = server.address().port + 10;
			newcb = cb;
			cb = null;
		}
		server.once(&#39;close&#39;, function () {
			cb &amp;&amp; cb(true, port);
			if (newcb) {
				// we need to verify our new port assigned to
				// make sure it&#39;s available since platforms don&#39;t
				// guarantee they are available
				// http://stackoverflow.com/questions/9901043/how-does-node-js-choose-random-ports
				return isPortAvailable(port, newcb, tries);
			}
		});
		server.close();
	});
	server.once(&#39;error&#39;, function (err) {
		try {
			server.close();
		}
		catch (e) {
		}
		if (err.code !== &#39;EADDRINUSE&#39; || tries &gt; 3) {
			cb &amp;&amp; cb(false);
		} else {
			// on restart, sometimes a bind will fail, so let&#39;s try it again
			// for up to 3 times
			setTimeout(function () {
				isPortAvailable(port, cb, tries);
			}, 10);
		}
	});
}

<span id='Arrow-method-start'>/**
</span> * Starts the server.
 * @param {Function} [callback] Callback passed an Error object.
 * @throws Error
 */
Arrow.prototype.start = function start(callback) {

	// this can happen if you call loadOnly in constructor and then later
	// try and start the server
	if (!this.app) {
		var error = new Error(&#39;invalid state. no internal app was created. did you call loadOnly in the Arrow constructor?&#39;);
		if (callback) {
			return callback(error);
		} else {
			throw error;
		}
	}

	// if we started and then stopped and now we&#39;re restarting, we need to reload this
	if (this.shuttingdown) {
		this.logger.trace(&#39;re-start after a shutdown&#39;);
		var self = this;
		this.shuttingdown = false;
		return async.each(this.apis, function (api, cb) {
			api.remove(self, cb);
		}, function (err) {
			if (err) { return callback(err); }
			async.each(self.routes, function (route, cb) {
				if (route) {
					route.remove(self, cb);
				} else {
					cb();
				}
			}, function (err) {
				if (err) { return callback(err); }
				Object.keys(self.blocks).forEach(function (name) {
					var block = self.blocks[name];
					block.removeAllListeners();
				});
				self.models = {};
				self.apis = [];
				self.blocks = {};
				self.routes = [];
				self.load(function (err) {
					if (err) { return callback(err); }
					self.start(callback);
				});
			});
		});
	}

	if (!callback) {
		callback = function (err) {
			if (err) {
				this.logger.error(&#39;server failed to start&#39;);
				this.logger.error(err);
			} else {
				if (this.port) {
					this.logger.info(&#39;server started on port&#39;, this.port);
				} else {
					this.logger.info(&#39;server started&#39;);
				}
			}
		}.bind(this);
	}

	if (!this.loaded) {
		this.logger.debug(&#39;waiting on server to finish loading&#39;);
		// we haven&#39;t finished loading, wait for the loading event to
		// fire and then re-entrant the start function
		return this.on(&#39;loaded&#39;, function () {
			return this.start(callback);
		}.bind(this));
	}

	this.logger.debug(&#39;starting&#39;, this.port);
	this.emit(&#39;starting&#39;);
	if (process.send &amp;&amp; process.connected) { process.send(&#39;starting&#39;); }

	var tasks = [],
		listener,
		instance = this;

	// start any connectors that haven&#39;t been connected
	Object.keys(connectors).forEach(function connectorIterator(connectorName) {
		var connector = connectors[connectorName];
		if (!connector.connected) {
			tasks.push(function connectorConnectTask(cb) {
				startConnector(instance, connector, cb);
			});
		}
	});

	// turn our models into apis
	tasks.push(function createModelAPIs(next) {
		this.createAPIsFromModels();
		next();
	}.bind(this));

	// check our APIs and Routes for uniqueness
	tasks.push(function checkAPIs(next) {
		var uniqueMap = {},
			routesAndAPIs = [].concat(this.apis, this.routes);
		for (var i = 0; i &lt; routesAndAPIs.length; i++) {
			var obj = routesAndAPIs[i];
			// replace path params to a placeholder identifier. /foo/:id and /foo/:bar should collide
			var pathTransformed = obj.path.replace(/(\:(.*?)(?=\/|$))/g, &#39;:pathParamPlacehdr&#39;);
			if (!obj.enabled) {
				continue;
			} else if (uniqueMap[obj.method.toLowerCase() + &#39;:&#39; + pathTransformed]) {
				this.logger.warn(&#39;Multiple APIs or Routes registered for the same path and method; please disable or change the path of all but one of them for consistent results:&#39;);
				this.logger.warn(&#39; - &#39; + obj.method + &#39; &#39; + obj.path);
				this.logger.warn(&#39; - to disable a Model method, use `actions: [ ... ]` or `disabledActions: [ &quot;&#39; + obj.describes + &#39;&quot; ]`&#39;);
				this.logger.warn(&#39; - to disable an API or Route, use `enabled: false&#39;);
				break;
			} else {
				uniqueMap[obj.method.toLowerCase() + &#39;:&#39; + pathTransformed] = true;
			}
		}
		// check endpoints for duplicate routes, if found, mark the whole endpoint invalid
		var endpointsMap = {};
		Object.keys(this.endpoints).forEach(function (ep) {
			var basepath = Endpoints.getRuntimeBasePath(this, this.endpoints[ep]);
			Object.keys(this.endpoints[ep].paths).forEach(function (path) {
				Object.keys(this.endpoints[ep].paths[path]).forEach(function (method) {
					var fullpath = basepath + path;
					fullpath = Endpoints.endpointToExpress(fullpath);
					// replace path params to a placeholder identifier. /foo/:id and /foo/:bar should collide
					var pathTransformed = fullpath.replace(/(\:(.*?)(?=\/|$))/g, &#39;:pathParamPlacehdr&#39;);
					var pathSignature = method + &#39;:&#39; + pathTransformed;
					var msg;

					// if route clashes with other endpoints, disable both endpoints
					if (endpointsMap[pathSignature]) {
						msg = &#39;Invalid Endpoint for path &quot;&#39; + method.toUpperCase() + &#39; &#39; + path + &#39;&quot;: Duplicate path found in Endpoint &quot;&#39; + endpointsMap[pathSignature] + &#39;&quot;&#39;;
						this.logger.warn(msg);
						this.logger.warn(&#39; - to disable an API or Route, use `enabled: false`&#39;);
						this.logger.warn(&#39; - to disable flow based API endpoints group, use `x-enabled: { enabled: false }`&#39;);
						this.endpoints[ep] = Endpoints.markInvalid(this.endpoints[ep], msg);
						this.endpoints[endpointsMap[pathSignature]] = Endpoints.markInvalid(this.endpoints[endpointsMap[pathSignature]], msg);
					} else {
						endpointsMap[pathSignature] = ep;
					}

					// if route clashes with API/Routes, disable the endpoint
					if (uniqueMap[pathSignature]) {
						msg = &#39;Invalid Endpoint for path &quot;&#39; + method.toUpperCase() + &#39; &#39; + path + &#39;&quot;: Multiple APIs or Routes registered for the same path and method&#39;;
						this.logger.warn(msg);
						this.logger.warn(&#39; - to disable an API or Route, use `enabled: false`&#39;);
						this.logger.warn(&#39; - to disable flow based API endpoints group, use `x-enabled: { enabled: false }`&#39;);
						this.endpoints[ep] = Endpoints.markInvalid(this.endpoints[ep], msg);
					} else {
						uniqueMap[pathSignature] = true;
					}
				}.bind(this));
			}.bind(this));
		}.bind(this));
		next();
	}.bind(this));

	// check the port to make sure its free
	tasks.push(function checkPortTask(next) {
		isPortAvailable(this.port, function (available, port) {
			if (!available) {
				return next(new Error(&#39;Assigned port (&#39; + this.port + &#39;) is already in use. &#39; +
					&#39;Please see if you have a running instance of this service on this machine. &#39; +
					&#39;You can also specify the port using the PORT environment variable when starting &#39; +
					&#39;the server or change in your config file.&#39;));
			}
			// assign it in case it was wildcard
			this.port = port || this.port;
			return next();
		}.bind(this));
	}.bind(this));

	// bind our apis
	tasks.push(function (next) {
		sortAPIsOrRoutes(this.apis);
		var keys = {};
		this.apis.forEach(function (api) {
			if (api.enabled) {
				// keep track of already bound apis and only bind once (save memory)
				var key = api.method + api.path;
				if (key in keys) {
					return;
				}
				keys[key] = 1;
				api.bind(instance.app);
			}
		});
		next();
	}.bind(this));

	// bind our endpoints to flows
	tasks.push(function (next) {
		Endpoints.bind(instance, this.endpoints);
		next();
	}.bind(this));

	// bind our routes
	tasks.push(function (next) {
		sortAPIsOrRoutes(this.routes);
		var keys = {};
		this.routes.forEach(function (route) {
			if (route.enabled) {
				// keep track of already bound routes and only bind once (save memory)
				var key = route.method + route.path;
				if (key in keys) {
					return;
				}
				keys[key] = 1;
				route.bind(instance.app);
			}
		});
		next();
	}.bind(this));

	// bind swagger routes
	tasks.push(function (next) {
		bindSwaggerRoutes(this);
		next();
	}.bind(this));

	// start the admin server
	tasks.push(function (next) {
		if (this.admin) {
			this.admin.start(this, next);
		} else {
			next();
		}
	}.bind(this));

	// start up the server
	tasks.push(function appListenTask(next) {
		this.emit(&#39;listening&#39;);
		if (process.send &amp;&amp; process.connected) { process.send(&#39;listening&#39;); }
		if (this.config.ssl &amp;&amp; (!inProduction || this.config.sslInProduction)) {
			var https = require(&#39;https&#39;);
			var sslPort = process.env.SSLPORT || this.config.ssl.port || 8443;
			this.sslServer = https.createServer(this.config.ssl, this.app).listen(sslPort);
			if (this.config.timeout !== undefined) {
				this.sslServer.setTimeout(this.config.timeout);
			}
			this.logger.info(&#39;SSL bound to port&#39;, sslPort);
			this.sslPort = sslPort;
		}
		this.server = this.app.listen(this.port, next);
		var nextSocketId = 0;
		this.server.on(&#39;connection&#39;, function (socket) {
			var socketId = nextSocketId++;
			openSockets[socketId] = socket;

			socket.on(&#39;close&#39;, function () {
				delete openSockets[socketId];
			});
		});

		if (this.config.timeout !== undefined) {
			this.server.setTimeout(this.config.timeout);
		}
	}.bind(this));

	// start the log manager
	tasks.push(function logManagerTask(next) {
		if (this.logmanager) {
			this.logmanager.start();
		}
		next();
	}.bind(this));

	// check if dev and production node version match
	tasks.push(function checkNodeVersion(next) {
		pluginUtil.printSpecifyNodeVersionWarningIfRequired(this.productionNodeVersion, this.logger);
		next();
	}.bind(this));

	tasks.push(function startedTask(next) {
		this.logger.info(&#39;started&#39;);
		this.emit(&#39;listen&#39;);
		this.emit(&#39;started&#39;);
		if (process.send &amp;&amp; process.connected) { process.send(&#39;listen&#39;); }
		if (process.send &amp;&amp; process.connected) { process.send(&#39;started&#39;); }
		this.proxy &amp;&amp; listener &amp;&amp; this.proxy.removeListener(&#39;connected&#39;, listener);
		servers.push(this);
		next();
	}.bind(this));

	if (process.argv.indexOf(&#39;--repl&#39;) &gt;= 0) {
		tasks.push(function startRepl(next) {
			var server = this;
			process.nextTick(function () {
				console.log(&#39;&#39;);
				var r = require(&#39;repl&#39;).start({
					prompt: &#39;API Builder Tools&gt; &#39;,
					useColors: true,
					useGlobal: true
				});
				r.context.server = server;
				r.context.Arrow = Arrow;
				r.context._ = _;
				r.context.fs = fs;
				r.context.path = path;
				r.on(&#39;exit&#39;, function () {
					server.stop();
				});
			});
			next();
		}.bind(this));
	}

	async.series(tasks, function (err) {
		err &amp;&amp; this.emit(&#39;error&#39;, err);
		callback(err);
	}.bind(this));
};

<span id='Arrow-method-createAPIsFromModels'>/**
</span> * Generates the standardized APIs from all loaded models.
 */
Arrow.prototype.createAPIsFromModels = function () {
	Object.keys(this.models).forEach(function routeModelIterator(name) {
		var model = this.models[name];
		this.createAPIsFromModel(model);
	}.bind(this));
};

<span id='Arrow-method-createAPIsFromModel'>/**
</span> * Generates the standardized APIs from a particular model.
 */
Arrow.prototype.createAPIsFromModel = function (model) {
	if (model.connector &amp;&amp; _.isString(model.connector)) {
		try {
			model._connector = model.connector;
			model.connector = this.getConnector(model.connector, true);
			model.connector.emit(&#39;init-model&#39;, model);
		}
		catch (E) {
			this.logger.trace(E.stack);
			throw new Error(&#39;Error loading connector: &#39; + model._connector + &#39; for model: &#39; + model.name + &#39;. &#39; + E.message);
		}
	}
	if (model.autogen) {
		var modelAPIs = makeAPIsFromModel(model, this.config.apiPrefix);
		modelAPIs.forEach(function modelAPIConstructorIterator(API) {
			var api = new API(this.objConfig, this);
			this.apis.push(api);
		}.bind(this));
	}
};

<span id='Arrow-method-sortAPIsOrRoutes'>/**
</span> * Sort the APIs or Routes (we need wildcard paths to be registered later in the process).
 */
function sortAPIsOrRoutes(apisOrRoutes) {
	apisOrRoutes.sort(function (a, b) {
		if (a.sort &lt; b.sort) {
			return 1;
		} else if (a.sort &gt; b.sort) {
			return -1;
		}
		// shortest paths first
		return a.path.length &gt; b.path.length;
	});
}

function makeAPIsFromModel(model, apiPrefix) {
	// if autogen off, don&#39;t generate APIs for Model
	if (!model.autogen || (model.connector &amp;&amp; model.connector.enabled === false) || !model.connector) {
		return [];
	}

	var apis = [],
		name = model.name;

	model.prefix = model.prefix || apiPrefix + &#39;/&#39; + name.toLowerCase();
	model.singular = model.singular || pluralize(name.toLowerCase(), 1);
	model.plural = model.plural || pluralize(name.toLowerCase());

	for (var key in model) {
		if (key.slice(-3) === &#39;API&#39;) {
			var val = model[key],
				isAPIDescriptor = _.isFunction(val),
				describes = key.slice(0, -3),
				describesUC = describes.substr(0, 1).toUpperCase() + describes.substr(1),
				enabled = true;

			if (!isAPIDescriptor) {
				continue;
			}
			var api = model[key]();
			if (!api) {
				continue;
			}

			// Check to see if the underlying connector has the necessary methods to support this API.
			var connectorMethods = (api.dependsOnAny || api.dependsOnAll || [describes]).filter(function (depConnectorMethod) {
				return !!model.getConnector()[depConnectorMethod];
			});
			if (connectorMethods.length &lt; (api.dependsOnAll ? api.dependsOnAll.length : 1)) {
				enabled = false;
				delete api.enabled;
			}

			// Should we disable based on our action or action groups being disabled?
			if (model.actions.indexOf(describes) === -1 &amp;&amp; (!api.actionGroup || model.actions.indexOf(api.actionGroup) === -1)) {
				enabled = false;
			}
			if (model.disabledActions &amp;&amp; model.disabledActions.indexOf(describes) &gt;= 0) {
				enabled = false;
				delete api.enabled;
			}

			// Handle some defaults for the API.
			if (!api.path) {
				api.path = model.prefix;
			} else if (api.path.substr(0, 2) === &#39;./&#39;) {
				api.path = model.prefix + api.path.substr(1);
			}
			_.defaultsDeep(api, {
				responses: {
					401: {
						description: &#39;This request requires user authentication, as configured by the server.&#39;,
						schema: {
							$ref: &#39;#/definitions/ErrorModel&#39;
						}
					},
					404: {
						description: &#39;No results were found.&#39;,
						schema: {
							$ref: &#39;#/definitions/ErrorModel&#39;
						}
					},
					500: {
						description: &#39;Something went wrong during the request; check out the logs on your server.&#39;,
						schema: {
							$ref: &#39;#/definitions/ErrorModel&#39;
						}
					},
					504: {
						description: &#39;The request took too long to process, and the server timed it out.&#39;,
						schema: {
							$ref: &#39;#/definitions/ErrorModel&#39;
						}
					},
					&#39;default&#39;: {
						description: &#39;Response from Server&#39;,
						schema: {
							$ref: &#39;#/definitions/ResponseModel&#39;
						}
					}
				}
			});

			apis.push(API.extend(_.defaults(api, {
				uiSort: Number.MAX_VALUE,
				enabled: enabled,
				generated: true,
				documented: model.documented === undefined ? model.connector.config.documented : model.documented,
				group: name,
				describes: describes,
				method: &#39;GET&#39;,
				parameters: {},
				singular: model.singular,
				plural: model.plural,
				model: name,
				pre: _.flatten(_.compact([
					model[&#39;pre&#39; + describesUC], model[&#39;before&#39; + describesUC],
					model[&#39;pre&#39; + (api.method || &#39;GET&#39;)], model[&#39;before&#39; + (api.method || &#39;GET&#39;)],
					model.pre, model.before
				])),
				post: _.flatten(_.compact([
					model[&#39;post&#39; + describesUC], model[&#39;after&#39; + describesUC],
					model[&#39;post&#39; + (api.method || &#39;GET&#39;)], model[&#39;after&#39; + (api.method || &#39;GET&#39;)],
					model.post, model.after
				]))
			})));
		}
	}

	return apis;
}

<span id='Arrow-method-removeAPIByFilename'>/**
</span> * Removes an API from the server.
 * @param {String} filename Name of the file of the API to remove.
 * @param {Function} [callback] Callback function passed an Error object (or null if successful).
 */
Arrow.prototype.removeAPIByFilename = function removeAPIByFilename(filename, callback) {
	var api = _.filter(this.apis, function (api) {
		return api.filename === filename;
	})[0];

	if (api) {
		api.remove(this, function (err) {
			this.triggerReloadedIfRequired(true, {filename: api}, err);
			callback &amp;&amp; callback();
		}.bind(this));
	} else {
		callback &amp;&amp; callback(new Error(&#39;couldn\&#39;t find an API at &#39; + filename));
	}
};

<span id='Arrow-method-reload'>/**
</span> * Reloads any changes found in Models, Blocks, Routes or APIs.
 * @param {Function} [callback] Callback to execute after the reload.
 */
Arrow.prototype.reload = function reload(callback) {
	this.logger.debug(&#39;reload called&#39;);
	this.stop(function () {
		delete this.config.apikey;
		globalArrow = new Arrow(this.config);
		globalArrow.start(function (err) {
			this.logger.debug(&#39;reload finished!&#39;);
			callback &amp;&amp; callback();
		}.bind(this));
	}.bind(this));
};

<span id='Arrow-method-stop'>/**
</span> * Stops the Arrow server instance.
 * @param {Function} [callback] Callback to execute after the server stops.
 */
Arrow.prototype.stop = function stop(callback) {
	this.shuttingdown = true;

	if (this.server &amp;&amp; !this.stopped) {

		for (var c = 0; c &lt; servers.length; c++) {
			var server = servers[c];
			if (server === this) {
				servers.splice(c, 1);
				break;
			}
		}

		this.stopped = true;
		this.logger.debug(&#39;stopping&#39;);
		this.emit(&#39;stopping&#39;);
		if (process.send &amp;&amp; process.connected) { process.send(&#39;stopping&#39;); }

		var tasks = [];

		// first stop the server so we don&#39;t serve request
		tasks.push(function serverCloseTask(next) {
			try {
				// ignore any errors on shutdown

				this.server.close(function (err) {
					next();
				});
				Object.keys(openSockets).forEach(function (socketID) {
					openSockets[socketID].destroy();
				});
			}
			catch (E) {
				next();
			}
		}.bind(this));

		// stop the SSL server if we have one
		if (this.sslServer) {
			tasks.push(function serverCloseTask(next) {
				try {
					// ignore any errors on shutdown
					this.sslServer.close(function (err) {
						next();
					});
				}
				catch (E) {
					next();
				}
			}.bind(this));
		}

<span id='Arrow-property-'>		/**
</span>		 * Disconnect all connectors if provided a disconnect method
		 * Delete the models associated with the connector (generated and fs)
		 * so that we don&#39;t run into duplicate errors when loadComponents tries to load fs models.
		 * Delete the _createdModelsFromSchema flag so arrow-orm knows to re-grab models from schema (generated).
		 * Delete connector.started so startConnector() will kick off
		 */
		Object.keys(connectors).forEach(function stopConnectorIterator(name) {
			var connector = connectors[name];
			connector.disconnect &amp;&amp; tasks.push(function connectorDisconnectTask(next) {
				connector.disconnect(next);
			});

			tasks.push(function resetConnectors(next) {
				delete connectors[name];
				next();
			}.bind(this));
		}.bind(this));

		// stop the log manager
		tasks.push(function (next) {
			if (this.logmanager) {
				this.logmanager.stop();
			}
			next();
		}.bind(this));

		// stop the handlerbars watcher if running
		tasks.push(function (next) {
			var handlebars = this.getMiddleware().getRendererEngine(&#39;hbs&#39;);
			handlebars &amp;&amp; handlebars.cleanupWatchers();
			next();
		}.bind(this));

		// now fire our lifecycle event
		async.series(tasks, function asyncCallback() {
			this.emit(&#39;stopped&#39;);
			if (process.send &amp;&amp; process.connected) { process.send(&#39;stopped&#39;); }
			this.logger.info(&#39;stopped&#39;);
			loadedModelDirs = [];
			callback &amp;&amp; callback();
		}.bind(this));
	} else {
		loadedModelDirs = [];
		callback &amp;&amp; callback();
	}

};

<span id='Arrow-method-createLogger'>/**
</span> * @method createLogger
 * Creates a logger instance.
 * @param {Object} config
 * @param {Object} opts Additional initialization options.
 * Refer to the [bunyan documentation](https://www.npmjs.com/package/bunyan).
 * @returns {Arrow.Logger}
 */
<span id='Arrow-static-method-createLogger'>/**
</span> * @method createLogger
 * @static
 * Creates a logger instance.
 * @param {Object} config
 * @param {Object} opts Additional initialization options.
 * Refer to the [bunyan documentation](https://www.npmjs.com/package/bunyan).
 * @returns {Arrow.Logger}
 */
Arrow.prototype.createLogger =
	Arrow.createLogger = function createLogger(config, opts) {
		return Logger.createLogger(_.merge(config, opts));
	};

// create a continuation monkey patch in the case the server hasn&#39;t yet loaded
// and we&#39;ve created a Model
function createModelClassContinuationPatch(Model) {
	if (globalArrow &amp;&amp; !globalArrow.loaded) {
		// monkey patch any methods that must have a valid connector that is running before we can call it
		var methods = [
			&#39;create&#39;, &#39;delete&#39;, &#39;replace&#39;, &#39;save&#39;, &#39;update&#39;, &#39;delete&#39;, &#39;deleteAll&#39;, &#39;find&#39;, &#39;findAll&#39;, &#39;findByID&#39;,
			&#39;findById&#39;, &#39;findOne&#39;, &#39;fetch&#39;, &#39;query&#39;, &#39;remove&#39;, &#39;removeAll&#39;
		];
		methods.forEach(function (fnName) {
			var ModelFn = Model[fnName];
			if (ModelFn) {
				Model[fnName] = createModelMethodMonkeyPatch(Model, ModelFn, fnName);
			}
		});

		// unwrap the methods after the arrow loads
		var builderLoader = function builderLoader() {
			var methods = [
				&#39;create&#39;, &#39;delete&#39;, &#39;replace&#39;, &#39;save&#39;, &#39;update&#39;, &#39;delete&#39;, &#39;deleteAll&#39;, &#39;find&#39;, &#39;findAll&#39;, &#39;findByID&#39;,
				&#39;findById&#39;, &#39;findOne&#39;, &#39;fetch&#39;, &#39;query&#39;, &#39;remove&#39;, &#39;removeAll&#39;
			];
			methods.forEach(function (fnName) {
				if (Model[fnName] &amp;&amp; Model[fnName].originalFunction) {
					Model[fnName] = Model[fnName].originalFunction;
				}
			});
			globalArrow.removeListener(&#39;loaded&#39;, builderLoader);
		};
		globalArrow.on(&#39;loaded&#39;, builderLoader);
	}
}

// create a function wrapper that will watch for the server to finish loading
// (which will have started the connectors) before we actually continue with the
// function. the method (fn) being passed in must be async for this to work
function createModelMethodMonkeyPatch(ModelClass, fn, name) {
	// if we&#39;re not yet loaded, we can&#39;t call methods against the
	// ModelClass. in which case we&#39;re going to wait until we&#39;re loaded
	// and then once loaded, we&#39;ll continue
	function modelMethodMonkeyPatched() {
		var args = arguments;
		var builderLoader = function builderLoader() {
			// make sure we resolve the connector to the real connector instance
			if (_.isString(ModelClass.connector)) {
				ModelClass.connector = Arrow.getConnector(ModelClass.connector);
			}
			globalArrow.removeListener(&#39;loaded&#39;, builderLoader);
			// re-patch it back to the original so subsequent doesn&#39;t come back through this block anymore
			ModelClass[name] = fn;
			// go ahead invoke
			return fn.apply(ModelClass, args);
		};
		// wait for loaded to fire
		if (globalArrow.loaded) {
			builderLoader();
		} else {
			globalArrow.on(&#39;loaded&#39;, builderLoader);
		}
	}

	modelMethodMonkeyPatched.originalFunction = fn;

	return modelMethodMonkeyPatched;
}

/*
 * monkey patch Model.extend to make sure that we set the instance of the
 * connector before returning
 */
var ModelExtend = Arrow.Model.extend;
var ModelReduce = Arrow.Model.reduce;

Arrow.Model.extend = createModelMonkeyPatch(ModelExtend, &#39;extend&#39;);
Arrow.Model.reduce = createModelMonkeyPatch(ModelReduce, &#39;reduce&#39;);

function createModelMonkeyPatch(ModelClass, method) {
	var createModel = function createModel() {
		// if we&#39;re extending a named model, resolve it first
		var model;
		if (arguments.length === 3) {
			// if we&#39;re in the middle of loading models on startup, we need to deal
			// with the case we are extending a model that has not been loaded yet,
			// in which case we want to record the dependency and then load later
			if (globalArrow &amp;&amp; globalArrow.loadingModels) {
				var args = arguments,
					self = this,
					fn = function () {
						globalArrow.removeListener(&#39;loadedModels&#39;, fn);
						return createModel.apply(self, args);
					};
				return globalArrow.on(&#39;loadedModels&#39;, fn);
			}
			// tricky. we need to check to see if the incoming connector referenced by
			// the new model is referencing a connector that is disabled and if so, just
			// return null so that the model load just fails silently (which is OK)
			if (arguments[2].connector) {
				var connector = _.isString(arguments[2].connector) ? Arrow.getConnector(arguments[2].connector) : arguments[2].connector;
				if (connector &amp;&amp; !connector.enabled) {
					var connectorName = connector.name || arguments[2].connector;
					globalArrow &amp;&amp; globalArrow.logger.debug(&#39;connector (&#39; + connectorName + &#39;) disabled, skipping model&#39;, arguments[1]);
					return;
				}
			}
			var extendModel = _.isString(arguments[0]) ? Arrow.getModel(arguments[0], true) : arguments[0],
				name = arguments[1],
				def = arguments[2];
			model = extendModel[method](name, def);
			// we need to set in case it wasn&#39;t set. this happens in cases where we loaded async
			model.name = name;
			model._parent = extendModel;
			model._supermodel = extendModel.name;
			if (!model.connector) {
				model.connector = extendModel.connector;
			}
			// if the extended model is autogen (like a built-in connector model) but we didn&#39;t
			// specify one in our own definition, assume we want to autogen it
			if (!extendModel.autogen &amp;&amp; def.autogen === undefined) {
				model.autogen = true;
			}
			// make sure we record it. this happens in the case we async load and we didn&#39;t put it in
			// because of that...
			if (!isModelDuplicate(model.name)) {
				globalArrow.models[model.name] = model;
			}
		} else {
			// else we&#39;re creating a simple new model
			model = ModelClass.apply(Arrow.Model, arguments);
			isModelDuplicate(model.name);
		}

		if (model.connector &amp;&amp; _.isString(model.connector)) {
			// if we&#39;re running and we have a string, resolve it
			if (globalArrow &amp;&amp; globalArrow.loaded) {
				model._connector = model.connector;
				model.connector = Arrow.getConnector(model.connector, true);
				model.connector.emit(&#39;init-model&#39;, model);
			} else {
				// we need to monkey patch to create continuation
				createModelClassContinuationPatch(model);
			}
		} else if (model.connector) {
			model.connector.emit(&#39;init-model&#39;, model);
		}

		return model;
	};
	return createModel;
}

<span id='Arrow-static-method-createModel'>/**
</span> * Creates a model class.
 * @static
 * @param {String} name Name of the new Model.
 * @param {ArrowModelDefinition} definition Model definition object.
 * @returns {Arrow.Model}
 */
Arrow.createModel = function _createModel() {
	return globalArrow.createModel.apply(globalArrow, arguments);
};

<span id='Arrow-method-createModel'>/**
</span> * @method createModel
 * @alias #static-method-createModel
 */
Arrow.prototype.createModel = Arrow.Model.extend;

<span id='Arrow-method-addModel'>/**
</span> * Adds a model class(es) on this instance.
 * @param {Arrow.Model/Array&lt;Arrow.Model&gt;} model Model class(es) to add.
 */
Arrow.prototype.addModel = function addModel(model) {
	for (var c = 0; c &lt; arguments.length; c++) {
		var ModelClass = arguments[c];
		if (!isModelDuplicate(ModelClass.name)) {
			this.models[ModelClass.name] = ModelClass;
		}
		// Has the server already started?
		if (this.server) {
			var startAt = this.apis.length;
			this.createAPIsFromModel(ModelClass);
			for (var i = startAt; i &lt; this.apis.length; i++) {
				this.apis[i].bind(this.app);
			}
		}
	}
};

<span id='Arrow-static-method-getModel'>/**
</span> * Gets a model by name.
 * @static
 * @param {String} name Name of the model to retrieve.
 * @param {Boolean} [failIfMissing] Set to `true` to throw an error if the model could not be found.
 * @returns {Arrow.Model}
 * @throws Error
 */
Arrow.getModel = function _getModel() {
	return globalArrow &amp;&amp; globalArrow.getModel.apply(globalArrow, arguments);
};

<span id='Arrow-method-getModel'>/**
</span> * @alias #static-method-getModel
 */
Arrow.prototype.getModel = function getModel(name, failIfMissing) {
	// in case you specify connector/appc.mysql/model - strip out the connector portion
	name = String(name || &#39;&#39;).replace(&#39;connector/&#39;, &#39;&#39;);
	var result = this.models[name];
	if (!result) {
		var tokens = name.split(&#39;/&#39;);
		if (tokens.length &gt; 1) {
			var connectorName = tokens[0],
				modelName = tokens[1],
				connector = connectors[connectorName];
			if (!connector &amp;&amp; failIfMissing) {
				throw new Error(&#39;Couldn\&#39;t find connector named: &#39; + connectorName);
			}
			result = connector &amp;&amp; connector.models &amp;&amp; (connector.models[modelName] || connector.models[connectorName + &#39;/&#39; + modelName] || connector.models[connector.name + &#39;/&#39; + modelName]);
		}
	}
	if (!result &amp;&amp; failIfMissing) {
		throw new Error(&#39;Couldn\&#39;t find model named: &#39; + name);
	}
	return result;
};

<span id='Arrow-method-getAPIs'>/**
</span> * Gets an array of APIs available to the instance.
 * @returns {Array&lt;Arrow.API&gt;}
 */
Arrow.prototype.getAPIs = function getAPIs() {
	return this.apis;
};

<span id='Arrow-method-getAPI'>/**
</span> * Returns an API for the given path and optional method in the case where more than one method.
 * may be invoked on a path. If you defined a nickname when creating the API instance, you may pass
 * the nickname to the function rather than the path and method.
 * @param {String} path Path of the API (or its nickname).
 * @param {String} [method] HTTP verb.
 * @returns {Arrow.API}
 */
Arrow.prototype.getAPI = function getAPI(path, method) {
	var pathAsRoute = path;
	if (path.substring(0, 1) !== &#39;/&#39;) {
		pathAsRoute = &#39;/&#39; + path;
	}
	for (var c = 0; c &lt; this.apis.length; c++) {
		if ((this.apis[c].path === pathAsRoute ||
			this.apis[c].nickname === path) &amp;&amp; (!method || (method &amp;&amp; this.apis[c].method.toUpperCase() === method.toUpperCase()))) {
			return this.apis[c];
		}
	}
};

<span id='Arrow-method-addAPI'>/**
</span> * Adds an API on this instance.
 * @param {Arrow.API} api API to add.
 */
Arrow.prototype.addAPI = function addAPI(APIConstructor) {
	if (_.isFunction(APIConstructor)) {
		var api = new APIConstructor(this.config, this);
		this.apis.push(api);
	} else {
		this.apis.push(APIConstructor);
	}
};

<span id='Arrow-method-getModels'>/**
</span> * Gets all models availabe to the instance.
 * @returns {Array&lt;Arrow.Model&gt;}
 */
Arrow.prototype.getModels = function getModels() {
	return this.models;
};

<span id='Arrow-method-getBlock'>/**
</span> * Gets a block by name.
 * @param {String} name Name of the block to retrieve.
 * @param {Boolean} [failIfMissing] Set to `true` to throw an error if the block could not be found.
 * @returns {Arrow.Block}
 * @throws Error
 */
Arrow.prototype.getBlock = function getBlock(name, failIfMissing) {
	var result = this.blocks[name];
	if (!result &amp;&amp; failIfMissing) {
		throw new Error(&#39;Couldn\&#39;t find block named: &#39; + name);
	}
	return result;
};

<span id='Arrow-method-getFlows'>/**
</span> * Gets all the flow definitions availabe to the instance.
 * @returns {Object}
 */
Arrow.prototype.getFlows = function getFlows() {
	return this.flowManager.getFlows();
};

<span id='Arrow-method-getFlow'>/**
</span> * Gets the flow definition by id.
 * @param {String} flowId The id of the flow to retrieve.
 * @returns {Object}
 */
Arrow.prototype.getFlow = function getFlow(flowId) {
	return this.flowManager.getFlow(flowId);
};

<span id='Arrow-method-getEndpoint'>/**
</span> * Gets an endpoint by path
 * @param  {String} endpoint The endpoint to get. ie &#39;/greet&#39;
 * @return {Object} or undefined
 */
Arrow.prototype.getEndpoint = function (endpoint) {
	return this.endpoints[endpoint];
};

<span id='Arrow-method-getEndpoints'>/**
</span> * Gets all loaded endpoints
 * @return {Object}
 */
Arrow.prototype.getEndpoints = function () {
	return this.endpoints || {};
};

<span id='Arrow-method-getRoute'>/**
</span> * Gets a route by name.
 * @param {String} name Name of the route to retrieve.
 * @param {Boolean} [failIfMissing] Set to `true` to throw an error if the route could not be found.
 * @returns {Arrow.Router}
 * @throws Error
 */
Arrow.prototype.getRoute = function getBlock(name, failIfMissing) {
	var result = _.findWhere(this.routes, {name: name});
	if (!result &amp;&amp; failIfMissing) {
		throw new Error(&#39;Couldn\&#39;t find route named: &#39; + name);
	}
	return result;
};

<span id='Arrow-method-addBlock'>/**
</span> * Adds the block(s) on this instance.
 * @param {Arrow.Block/Array&lt;Arrow.Block&gt;} block Block(s) to add.
 */
Arrow.prototype.addBlock = function () {
	for (var c = 0; c &lt; arguments.length; c++) {
		var Block = arguments[c];
		this.blocks[Block.name] = Block;
	}
};

<span id='Arrow-method-getBlocks'>/**
</span> * Gets all blocks.
 * @returns Array&lt;Arrow.Block&gt;
 */
Arrow.prototype.getBlocks = function getBlocks() {
	return this.blocks;
};

<span id='Arrow-method-getCodeblock'>/**
</span> * Gets a codeblock by name.
 * @param {String} name Name of the codeblock to retrieve.
 * @param {Boolean} [failIfMissing] Set to `true` to throw an error if the codeblock could not be found.
 * @returns {Arrow.Codeblock}
 * @throws Error
 */
Arrow.prototype.getCodeblock = function getCodeblock(name, failIfMissing) {
	var result = this.codeblocks[name];
	if (!result &amp;&amp; failIfMissing) {
		throw new Error(&#39;Couldn\&#39;t find codeblock named: &#39; + name);
	}
	return result;
};

<span id='Arrow-method-getCodeblocks'>/**
</span> * Gets all codeblocks.
 * @returns Array&lt;Arrow.Codeblock&gt;
 */
Arrow.prototype.getCodeblocks = function getCodeblocks() {
	return this.codeblocks;
};

<span id='Arrow-static-method-getConnector'>/**
</span> * Returns a registered connector by name.
 * @static
 * @param {String} name Name of the connector to retrieve.
 * @param {Boolean} [failIfMissing] Set to `true` to throw an error if the connector could not be found.
 * @throws Error
 */
Arrow.getConnector = function _getConnector() {
	if (!globalArrow) {
		throw new Error(&#39;an Arrow instance has not yet been created&#39;);
	}
	return globalArrow.getConnector.apply(globalArrow, arguments);
};

<span id='Arrow-method-getConnector'>/**
</span> * Gets a connector by name.
 * @param {String} name Name of the connector to retrieve.
 * @param {Boolean} [failIfMissing] Set to `true` to throw an error if the connector could not be found.
 * @throws Error
 */
Arrow.prototype.getConnector = function getConnector(name, failIfMissing) {
	if (!name) {
		throw new Error(&#39;missing name&#39;);
	}
	// trim off in case you specific connector/appc.salesforce which is acceptable
	name = name.replace(&#39;connector/&#39;, &#39;&#39;);
	var found = connectors[name],
		askedName = name;
	if (!found) {
		if (name === &#39;memory&#39;) {
			// use memory if not found and specified. this is nice for testing
			connectors[name] = found = new Arrow.MemoryConnector();
			return found;
		}
		var config = this.config || new Loader() || {};
		// see if this is a mapped connector and if so, lookup the real connector
		if (config.connectors &amp;&amp; name in config.connectors) {
			config = config.connectors[name];
			name = config.connector || askedName;
			config = config.config || config;
			// Note: we don&#39;t grab the cached `connectors[name]` because we need our own instance.
		} else if (config.connectors) {
			// not found, let&#39;s see if we have a connector specified
			var connectorsFound = _.filter(_.values(config.connectors), function (entry) {
				return entry.connector &amp;&amp; entry.connector === askedName;
			});
			if (connectorsFound.length &gt; 1) {
				this.logger.warn(&#39;Found &#39; + connectorsFound.length + &#39; connector configurations for &#39; + askedName + &#39;. &#39; +
					&#39;Using the first one found. If this isn\&#39;t the right connector, use the correct alias name to &#39; +
					&#39;specify the right connector&#39;);
				connectorsFound = [connectorsFound[0]];
			}
			if (connectorsFound.length === 1) {
				name = connectorsFound[0].connector || askedName;
				config = connectorsFound[0].config || connectorsFound[0];
			}
		}
		try {
			var ConnectorFactory = paths.findComponent(&#39;connector&#39;, name);
			if (ConnectorFactory) {
				if (!ConnectorFactory.create) {
					throw new Error(name + &#39; must be updated to use the Connector Factory API.  See https://jira.appcelerator.org/browse/API-138&#39;);
				}
				// re-entrant flag in case a Connector inadvertently calls Arrow.loadModelsForConnector
				// during this ConnectorFactory.create which will cause us to re-enter this method into an
				// infinite recursion problem .. so we note and then do it again later if we have this happen
				inGetConnector = true;
				var Connector = ConnectorFactory.create(Arrow, this);
				inGetConnector = false;
				found = new Connector(config[name] || config || {});
				if (found) {
					found.name = askedName;
					connectors[askedName] = found;
					// if we have a post create lifecycle callback, call it
					// this will allow connectors to do things like call Arrow.loadModelsForConnector
					// after the connector is instantiated but before it is returned. If we don&#39;t do this
					// we will get into an infinite loop where things done in the constructor (like load models)
					// that require the connector will attempt to re-instantiate the connector again (since it&#39;s not done registering)
					if (pendingModels) {
						found.models = Arrow.loadModelsForConnector(found.name, pendingModels.module, pendingModels.dir);
						pendingModels = null;
					}
					if (found.postCreate) {
						found.postCreate.call(found);
					}
				}
			}
		}
		catch (E) {
			this.logger.error(&#39;Error loading connector: &#39; + name, E);
			throw E;
		}
	}
	if (!found &amp;&amp; name === &#39;memory&#39;) {
		// use memory if not found and specified. this is nice for testing
		connectors[name] = found = new Arrow.MemoryConnector();
	}
	if (!found &amp;&amp; failIfMissing) {
		throw new Error(&#39;Couldn\&#39;t find connector named: &#39; + name);
	}
	return found;
};

<span id='Arrow-static-method-getConnectors'>/**
</span> * @method getConnectors
 * Gets a list of registered connectors.
 * @static
 * @returns {Array&lt;Arrow.Connector&gt;}
 */
<span id='Arrow-method-getConnectors'>/**
</span> * @method getConnectors
 * @alias #static-method-getConnectors
 */
Arrow.getConnectors =
	Arrow.prototype.getConnectors = function getConnectors() {
		return connectors;
	};

<span id='Arrow-static-method-registerConnector'>/**
</span> * @method registerConnector
 * @static
 * Registers a connector.
 * @param {Arrow.Connector} connector Connector to register.
 */
<span id='Arrow-method-registerConnector'>/**
</span> * @method registerConnector
 * @alias #static-method-registerConnector
 */
Arrow.registerConnector =
	Arrow.prototype.registerConnector = function registerConnector(connector) {
		connectors[connector.name] = connector;

		// attach a get model convenience function on the connector
		if (!connector.getModel) {
			connector.getModel = function (name) {
				return this.models &amp;&amp; (this.models[name] || this.models[this.name + &#39;/&#39; + name]);
			};
		}

		if (connector.models) {
			Object.keys(connector.models).forEach(function keyIterator(name) {
				var model = connector.models[name];
				// map to the real connector instance
				model.connector = connector;
			});
		}
	};

// listen for connectors that are being created
Connector.on(&#39;register&#39;, Arrow.registerConnector);

function loadModels(models, dir, connectorName) {
	if (loadedModelDirs.indexOf(dir) &gt;= 0) {
		return;
	}
	loadedModelDirs.push(dir);
	fs.readdirSync(dir).forEach(function modelResolver(name) {
		var p = path.join(dir, name);
		if (fs.statSync(p).isDirectory()) {
			loadModels(models, p, connectorName);
		} else if (path.extname(p) === &#39;.js&#39; &amp;&amp; path.basename(p).charAt(0) !== &#39;_&#39;) {
			// only do .js files that don&#39;t start with _
			var model = paths.requireComponent(p);
			if (model &amp;&amp; !(model.name in models)) {
				models[model.name] = model;
				globalArrow &amp;&amp; (model.connector = Arrow.getConnector(connectorName));
				model.filename = p;
				globalArrow &amp;&amp; globalArrow.addModel(model);
			} else {
				throw new Error(&#39;Model: &#39; + model.name + &#39; already exists in connector: &#39; + connectorName);
			}
		}
	});
}

<span id='Arrow-method-removeModel'>/**
</span> * Removes a model from this instance.
 * @param {Arrow.Model} model Model to remove.
 */
Arrow.prototype.removeModel = function (model) {
	delete this.models[model.name];
};

<span id='Arrow-method-removeConnector'>/**
</span> * Removes a connector.
 * @param {Arrow.Connector} connector Connector to remove.
 */
Arrow.prototype.removeConnector = function (connector) {
	delete this.connectors[connector.name];
};

<span id='Arrow-method-removeBlock'>/**
</span> * Removes a block.
 * @param {Arrow.Block} block Block to remove.
 */
Arrow.prototype.removeBlock = function (block) {
	delete this.blocks[block.name];
};

<span id='Arrow-method-removeAPI'>/**
</span> * Removes an API.
 * @param {Arrow.API} api API to remove.
 */
Arrow.prototype.removeAPI = function (api) {
	for (var c = 0; c &lt; this.apis.length; c++) {
		var a = this.apis[c];
		if (a === api) {
			this.apis.splice(c, 1);
			break;
		}
	}
	api.remove(this);
};

<span id='Arrow-method-removeRoute'>/**
</span> * Removes a route.
 * @param {Arrow.Router} route Route to remove.
 */
Arrow.prototype.removeRoute = function (route) {
	if (route) {
		for (var i = 0; i &lt; this.routes.length; i++) {
			var currentRoute = this.routes[i];
			if (currentRoute === route) {
				this.routes.splice(i, 1);
				break;
			}
		}
		route.remove(this);
	}
};

<span id='Arrow-method-toJSON'>/**
</span> * returns an Arrow toJSON description
 */
Arrow.prototype.toJSON = function () {
	return &#39;[object Arrow]&#39;;
};

<span id='Arrow-method-inspect'>/**
</span> * returns an util.inspect description
 */
Arrow.prototype.inspect = function () {
	return &#39;[object Arrow]&#39;;
};

<span id='Arrow-method-registerModelsForConnector'>/**
</span> * Dynamically loads the models into the server if the connector updates them dynamically
 * (i.e. after connect has run and started);
 */
Arrow.prototype.registerModelsForConnector = function registerModelsForConnector(connector, models) {
	if (!models || !_.isObject(models)) {
		throw new Error(&#39;Invalid argument passed to registerModelsForConnector: connector/&#39; + connector.name + &#39;; models must be an object.&#39;);
	}
	Object.keys(models).forEach(function (name) {
		var Model = models[name];
		if (Model.visible || Model.visible === undefined) {
			this.models[name] = Model;
		}
		if (Model.documented === undefined &amp;&amp; connector.config.documented !== undefined) {
			Model.documented = connector.config.documented;
		}
	}.bind(this));
};

<span id='Arrow-method-loadModelsForConnector'>/**
</span> * Called by a connector to attempt to load any connector bundled models.
 * @param {String} connectorName Name of the connector.
 * @param {Object} module Connector module instance.
 * @param {String} dir Directory of the connector&#39;s models. Default is the connector&#39;s models folder.
 */
Arrow.loadModelsForConnector = function loadModelsForConnector(connectorName, module, dir) {
	if (inGetConnector) {
		// handle re-entrant issue with ConnectorFactory that calls this during
		// instantiation if we&#39;re still loading. will cause us to do this after its done
		pendingModels = {module: module, dir: dir};
		return;
	}
	var modelsDir = path.resolve(dir || path.join(path.dirname(path.dirname(module.filename)), &#39;models&#39;));

	// attempt to load any models packaged with the connector
	if (fs.existsSync(modelsDir)) {
		var models = {};
		loadModels(models, modelsDir, connectorName);
		return models;
	}
};

// map helper functions
Arrow.pluralize = function doPluralize(name) {
	return pluralize(name);
};

Arrow.singularize = function doSingularize(name) {
	return pluralize(name, 1);
};

function createRequestTransaction(config) {
	var logging = config.logging || {},
		prefix = config.prefix,
		enabled = logging.transactionLogEnabled === undefined || logging.transactionLogEnabled;
	return function requestTx(req, resp, next) {
		// handle serialization to the log so that we only dump a subset of the object
		req.inspect = function () {
			return &#39;[object Request]&#39;;
		};
		req.toJSON = function () {
			return req.log.serializers.req(req);
		};
		resp.inspect = function () {
			return &#39;[object Response]&#39;;
		};
		resp.toJSON = function () {
			return req.log.serializers.res(resp);
		};
		if (!req.url || (req.url &amp;&amp; req.url.indexOf(prefix) === 0) || !enabled) {
			req.logmetadata = false;
			return next();
		}
		req.tx = new RequestTx(req, resp, prefix);
		next();
	};
}

<span id='Arrow-method-endRequestTransaction'>/**
</span> * called at the end of a request once it&#39;s done sending
 */
function endRequestTransaction(req, resp) {
	if (req.pendingReqCount) {
		pendingRequests--;
		if (pendingRequests &lt; 0) { pendingRequests = 0; }
		req.pendingReqCount = null;
		var logger = req.server.logger;
		// always fire since this also handles request logger in addition to transaction logger
		this.emit(&#39;txdone&#39;, req, resp);
		if (req.tx) {
			req.tx.done();
			req.tx = null;
		} else if (req.cleanStream) {
			req.cleanStream();
			req.cleanStream = null;
		}
		// if no pending requests and we haven&#39;t do a GC in awhile, let&#39;s attempt to GC if
		// our heap usage is &gt;1M
		if (memwatch &amp;&amp; pendingRequests === 0 &amp;&amp; (Date.now() - lastGCCheck) &gt; 60000) {
			lastGCCheck = Date.now();
			var heapUsed = process.memoryUsage().heapUsed / 1024;
			if (heapUsed &gt; 1000000) {
				(logger.debug || consoleLog)(&#39;triggering gc, heap usage&#39;, heapUsed + &#39;k&#39;);
				memwatch.gc();
			}
		}
	}
}

// shutdown all servers and then exit
function shutdownAllServers(exitCode, dontexit) {
	if (stopping) { return; }
	stopping = true;
	exitCode = exitCode === undefined ? 0 : exitCode;
	async.each(servers, function (server, cb) {
		server.stop(cb);
	}, function () {
		stopping = false;
		if (dontexit) { return; }
		process.exit(exitCode);
	});
}

// restart all servers by first stopping and then restarting them
function restartAllServers() {
	if (stopping) { return; }
	async.each(servers, function (server, cb) {
		server.pendingReload = true;
		server.loaded = false;
		server.stop(function (err) {
			if (err) { return cb(err); }
			stopping = false;
			pendingRequests = 0;
			server.pendingReload = false;
			server.start(function (err) {
				server.loaded = true;
				cb(err);
			});
		});
	});
}

// if not in production, remove our local logs on each shutdown
if (!inProduction) {
	debug(&#39;removing temporary log directory when in development on startup&#39;);
	process.on(&#39;exit&#39;, function (ec) {
		try {
			var wrench = require(&#39;wrench&#39;),
				path = require(&#39;path&#39;),
				fs = require(&#39;fs&#39;),
				logdir = Logger.arrowCloudLogDir || path.join((globalArrow &amp;&amp; globalArrow.config.dir) || process.cwd(), &#39;logs&#39;);
			if (fs.existsSync(logdir)) {
				try {
					wrench.rmdirSyncRecursive(logdir);
				}
				catch (E) {
					// ignore any errors
				}
			}
		}
		catch (E) {
		}
		cluster.isMaster &amp;&amp; process.exit(ec);
	});
}

// normal shutdown type signals
// for now, we&#39;re going to ignore SIGHUP since that can be sent on terminal
// disconnect or backgrounding
// we only use this when we&#39;re not in cluster mode. otherwise, let the cluster handle below
// if we are in master, assume that we aren&#39;t running with cluster (such as unit tests)
if (cluster.isMaster || cluster.isWorker) {
	[&#39;exit&#39;, &#39;SIGINT&#39;, &#39;SIGTERM&#39;, &#39;SIGQUIT&#39;].forEach(function (name) {
		process.on(name, shutdownAllServers);
	});

	// restart if we receive the SIGUSR2 signal
	process.on(&#39;SIGUSR2&#39;, function () {
		consoleLog(&#39;arrow.js: signal received SIGUSR2 restarting&#39;);
		restartAllServers();
	});
}

// on SIGABRT we are going to send an abort which should core on *nix platforms
process.on(&#39;SIGABRT&#39;, function () {
	shutdownAllServers(0, true);
	process.abort();
});

// monitor any unhandled exceptions
process.on(&#39;uncaughtException&#39;, function (error) {
	if (_.isObject(error)) {
		consoleLog(&#39;Uncaught Exception&#39;, error.message);
		try {
			error.stack &amp;&amp; consoleLog(error.stack);
		}
		catch (E) {
		}
	} else {
		consoleLog(&#39;Uncaught Exception&#39;, error);
	}
	// if we get an unhandled exception we need to crash the process
	process.exit(1);
});

// monitor any memory leaks
memwatch &amp;&amp; memwatch.on(&#39;leak&#39;, function (info) {
	consoleLog(&#39;memory leak detected&#39;, info);
});

if (cluster.isWorker) {
	// monitor any cluster messages
	process.on(&#39;message&#39;, function (msg) {
		/* jshint ignore:start */
		switch (msg) {
			case &#39;shutdown&#39;:
				return shutdownAllServers();
			case &#39;restart&#39;:
				return restartAllServers();
			default:
				break;
		}
		/* jshint ignore:end */
	});

}
</pre>
</body>
</html>
