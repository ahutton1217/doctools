<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*
 * This code is closed source and Confidential and Proprietary to
 * Appcelerator, Inc. All Rights Reserved.  This code MUST not be
 * modified, copied or otherwise redistributed without express
 * written permission of Appcelerator. This file is licensed as
 * part of the Appcelerator Platform and governed under the terms
 * of the Appcelerator license agreement.
 */

// jscs:disable
<span id='Arrow-Middleware'>/**
</span> * @class Arrow.Middleware
 */
// jscs:enable

var express = require(&#39;express&#39;),
	path = require(&#39;path&#39;),
	fs = require(&#39;fs&#39;),
	async = require(&#39;async&#39;),
	crypto = require(&#39;crypto&#39;),
	cookieParser = require(&#39;cookie-parser&#39;),
	bodyParser = require(&#39;body-parser&#39;),
	compression = require(&#39;compression&#39;),
	sessions = require(&#39;client-sessions&#39;),
	busboy = require(&#39;connect-busboy&#39;),
	_ = require(&#39;lodash&#39;),
	Arrow = require(&#39;./arrow&#39;),
	debug = require(&#39;debug&#39;)(&#39;appc:middleware&#39;),
	tmpdir = require(&#39;os&#39;).tmpdir(),
	cache = {},
	renderers = {};

// jscs:disable jsDoc

function Middleware(app, dirname, sessionConfig, config) {
	config = config || {};
	this.app = app;
	app.set(&#39;x-powered-by&#39;, false);
	// setup a handler that will emit the &#39;after&#39; event after the request completes
	var limit = (config.bodyParser || {}).limit || &#39;1mb&#39;;
	var secret = config.cookieSecret;
	app.use(cookieParser(secret));
	app.use(bodyParser.text({limit: limit}));
	app.use(bodyParser.raw({limit: limit}));
	app.use(bodyParser.json({limit: limit}));
	app.use(bodyParser.urlencoded({extended: false, limit: limit}));
	app.use(busboy(config.busboy || {}));
	app.use(function (req, resp, next) {
		if (req.busboy &amp;&amp; req.headers[&#39;content-type&#39;] &amp;&amp; req.headers[&#39;content-type&#39;].indexOf(&#39;multipart/form-data&#39;) === 0) {
			req.files = {};
			req.fields = {};
			var total = 0, count = 0, finished;
			req.busboy.on(&#39;file&#39;, function (fieldname, file, filename, encoding, mimetype) {
				var tmpfile = path.join(tmpdir, &#39;tmp-&#39; + (Date.now()) + &#39;_&#39; + filename);
				total++;
				debug(&#39;file &#39; + fieldname + &#39;, now total is&#39;, total);
				req.files[fieldname] = {
					file: tmpfile,
					filename: filename,
					encoding: encoding,
					mimetype: mimetype
				};
				var stream = fs.createWriteStream(tmpfile);
				stream.on(&#39;close&#39;, function () {
					debug(&#39;stream close, total=&#39;, total, &#39;count=&#39;, count);
					if (++count === total &amp;&amp; finished) {
						total = -1;
						debug(&#39;calling next 0&#39;, req.fields);
						debug(&#39;files=&#39;, req.files);
						process.nextTick(next);
					}
				});
				file.pipe(stream);
			});
			req.busboy.on(&#39;field&#39;, function (fieldname, val, fieldnameTruncated, valTruncated) {
				debug(&#39;field&#39;, fieldname);
				req.fields[fieldname] = {
					value: val,
					fieldnameTruncated: fieldnameTruncated,
					valueTruncated: valTruncated
				};
			});
			req.busboy.on(&#39;finish&#39;, function (err) {
				finished = true;
				debug(&#39;finish called total=&#39;, total, &#39;count=&#39;, count);
				if (err) { return next(err); }
				if (total &amp;&amp; count === total) {
					debug(&#39;calling next 1&#39;, req.fields);
					process.nextTick(next);
				} else if (total === 0) {
					debug(&#39;calling next 2&#39;, req.fields);
					process.nextTick(next);
				}
			});
			req.pipe(req.busboy);
		} else {
			next();
		}
	});
	app.use(function (req, resp, next) {
		if (req.body &amp;&amp; _.isObject(req.body) &amp;&amp; !(req.body instanceof Buffer)) {
			// we add to _params because express changes for each next
			req.params = req._params = _.merge(req.params, req.body);
		} else {
			req._params = req.params;
		}
		if (req.files || req.fields) {
			req.files &amp;&amp; Object.keys(req.files).forEach(function (name) {
				req.params[name] = req.files[name].file;
			});
			req.fields &amp;&amp; Object.keys(req.fields).forEach(function (name) {
				req.params[name] = req.fields[name].value;
			});
		}
		next();
	});
	app.use(compression());
	app.on(&#39;after&#39;, function (req, resp) {
		if (req &amp;&amp; req.files) {
			setTimeout(function () {
				async.each(req.files, function (entry, cb) {
					fs.unlink(entry.file, cb);
				});
				req.files = null;
			}, 500);
		}
		if (req &amp;&amp; req.res) {
			req.res.req = null;
		}
	});

	if (sessionConfig) {
		setupSession(app, sessionConfig);
	}

	var webDirectory = dirname &amp;&amp; path.join(dirname, &#39;web&#39;),
		publicDirectory = webDirectory &amp;&amp; path.join(webDirectory, &#39;public&#39;);

	if (publicDirectory &amp;&amp; fs.existsSync(publicDirectory)) {
		app.use(express.static(publicDirectory));
	}
	if (webDirectory) {
		registerRenderers(app, webDirectory);
	}

	var writeHead = express.response._originalWriteHead || express.response.writeHead;
	if (!express.response._originalWriteHead) {
		express.response._originalWriteHead = writeHead;
	}
	express.response.writeHead = function () {
		// if the user by passes this class and does their own writeHead, end, etc.
		// we need to catch it since it&#39;s out of order the way we do it in response.js
		// so just flag it and when we see this below, just assume we&#39;re good to go
		var called = this.bodyFlushed;
		this.bodyFlushed = this._flushBodyCalled = true;
		writeHead.apply(this, arguments);
		if (!called) {
			// if we get here it&#39;s because we&#39;re doing a non-API Route
			// in which case we need to trigger after event
			app.emit(&#39;after&#39;, this.req, this.req.res);
		}
	};
	// called by the response.js
	express.response._flushBody = function (content) {
		// var logger = (Arrow.getGlobal() || {}).logger;
		// logger &amp;&amp; logger.trace(&#39;_flushBody&#39;, new Error().stack);
		if (this.bodyFlushed) { return; }
		addEndHeaders(this.req, this, content);
		this.bodyFlushed = this._flushBodyCalled = true;
		this.end(content);
		app.emit(&#39;after&#39;, this.req, this.req.res);
	};
	var setHeader = express.response._originalSetHeader || express.response.setHeader;
	if (!express.response._originalSetHeader) {
		express.response._originalSetHeader = setHeader;
	}
	express.response.setHeader = function (k, v) {
		this._headers = this._headers || {};
		if (v) {
			setHeader.apply(this, arguments);
			this._headers[k.toLowerCase()] = v;
		} else {
			this.removeHeader(k);
		}
	};
	var removeHeader = express.response._originalRemoveHeader || express.response.removeHeader;
	if (!express.response._originalRemoveHeader) {
		express.response._originalRemoveHeader = removeHeader;
	}
	express.response.removeHeader = function (k) {
		removeHeader.apply(this, arguments);
		if (this._headers) {
			delete this._headers[k.toLowerCase()];
		}
	};
	express.response.headers = function () {
		return this._headers;
	};
	Object.defineProperty(express.response, &#39;contentType&#39;, {
		set: function (value) {
			this.setHeader(&#39;Content-Type&#39;, value);
		},
		get: function () {
			return this._headers[&#39;content-type&#39;] || this._headers[&#39;Content-Type&#39;];
		}
	});
	var render = express.response._originalRender || express.response.render;
	if (!express.response._originalRender) {
		express.response._originalRender = render;
	}
	express.response.render = function (name, locals) {
		if (locals &amp;&amp; _.isObject(locals)) {
			// make sure that we render any ORM objects as JSON instead of their real classes
			locals = _.cloneDeep(locals, objectCustomizer);
		}
		return render.apply(this, arguments);
	};
}

/*
 * Wrap response.send to add end headers.
 */
var expressResponseSend = express.response.send;
express.response.send = function wrappedResponseSend(content) {
	if (_.isNumber(arguments[0])) {
		throw new Error(&#39;don\&#39;t use resp.send with number. call resp.status instead&#39;);
	}
	addEndHeaders(this.req, this, content);
	expressResponseSend.call(this, content);
};

/*
 * convert our value into a valid JSON object
 */
function objectCustomizer(value) {
	if (value === undefined || value === null) { return value; }
	// return serialized JSON versions of our ORM data objects
	if (value instanceof Arrow.Instance || value instanceof Arrow.Collection || _.isFunction(value.toJSON)) {
		return value.toJSON();
	} else if (Array.isArray(value)) {
		var array = [];
		value.forEach(function (o) {
			array.push(_.cloneDeep(o, objectCustomizer));
		});
		return array;
	} /* don&#39;t serialize functions*/ else if (_.isFunction(value)) {
		return undefined;
	} else if (_.isObject(value)) {
		var obj = {};
		Object.keys(value).forEach(function (k) {
			var v = _.cloneDeep(value[k], objectCustomizer);
			obj[k] = v;
		});
		return obj;
	}
	return value;
}

function addEndHeaders(req, resp, content) {
	if (req &amp;&amp; req.tx) {
		resp.setHeader(&#39;Response-Time&#39;, String(Date.now() - req.tx.started));
	}
	if (content) {
		var c = String(content);
		resp.setHeader(&#39;Content-MD5&#39;, md5(c));
	}
}

function md5(value) {
	var hash = crypto.createHash(&#39;md5&#39;);
	hash.update(String(value));
	return hash.digest(&#39;hex&#39;);
}

function setupSession(app, sessionConfig) {
	app.use(
		sessions({
			// load from configuration
			encryptionAlgorithm: sessionConfig.encryptionAlgorithm || &#39;aes256&#39;,
			encryptionKey: new Buffer(sessionConfig.encryptionKey || &#39;8yOAsrmwQ7jcUJC7SS1bBmGLRYW0g0ucOwSDjmSOnKg=&#39;, &#39;base64&#39;),
			signatureAlgorithm: sessionConfig.signatureAlgorithm || &#39;sha512-drop256&#39;,
			signatureKey: new Buffer(sessionConfig.signatureKey || &#39;ub9VhdXWtQ6oN2UwhvkiRO0eS9S6OgAbHOAAPjKbW+Qd/A2OYGiZdjcrNliQU+ho4e5Dz5Wj4z2ggfefRjU3ug==&#39;, &#39;base64&#39;),
			cookieName: &#39;Arrow&#39;, // cookie name dictates the key name added to the request object - do not changed this or you will get an error
			secret: sessionConfig.secret || crypto.randomBytes(24).toString(&#39;base64&#39;), // should be a large unguessable string
			duration: sessionConfig.duration || 24 * 60 * 60 * 1000, // how long the session will stay valid in ms
			activeDuration: sessionConfig.activeDuration || 1000 * 60 * 5, // if expiresIn &lt; activeDuration, the session will be extended by activeDuration milliseconds
			cookie: sessionConfig.cookie || {}
		})
	);
	app.use(function sessionMapper(req, resp, next) {
		// set the session value to the name of our sessions object
		req.session = req.Arrow;
		// alias destroy to reset
		req.session.destroy = req.Arrow.reset;
		try {
			next();
		}
		catch (E) {
		}
	});
}

function createRenderer(app, ext, engine) {
	var cacheable = app.enabled(&#39;view cache&#39;);
	app.engine(ext, function templateRender(filePath, options, callback) {
		var entry = cache[filePath];
		if (!entry || !cacheable) {
			entry = engine.createRenderer(engine.skipread ? null : fs.readFileSync(filePath).toString(), filePath, app);
			if (cacheable) {
				cache[filePath] = entry;
			}
		}
		if (entry.length === 3) {
			entry(filePath, options, callback);
		} else {
			callback(null, entry(options));
		}
	});
}

<span id='Arrow-Middleware-method-registerRendererEngine'>/**
</span> * Registers a renderer engine for this instance.
 * @param {ArrowRendererEngine} engine Renderer engine.
 */
Middleware.prototype.registerRendererEngine = function registerRendererEngine(engine) {
	return Middleware.registerRendererEngine(this.app, engine);
};

<span id='Arrow-Middleware-static-method-registerRendererEngine'>/**
</span> * Registers a renderer engine.
 * @static
 * @param {Object} app App instance.
 * @param {ArrowRendererEngine} engine Renderer engine.
 */
Middleware.registerRendererEngine = function registerRendererEngine(app, engine) {
	createRenderer(app, engine.extension, engine);
	renderers[engine.extension] = engine;
};

<span id='Arrow-Middleware-static-method-getRendererEngine'>/**
</span> * @method getRendererEngine
 * @static
 * Returns a renderer engine for a given file extension.
 * @param {String} extension File extension to get a renderer engine for.
 * Built-in values are `ejs`, `hbs`, `html`, `jsx` and `md`.
 * @returns {ArrowRendererEngine}
 */
<span id='Arrow-Middleware-method-getRendererEngine'>/**
</span> * @method getRendererEngine
 * @alias #static-method-getRendererEngine
 */
Middleware.prototype.getRendererEngine =
	Middleware.getRendererEngine = function getRendererEngine(extension) {
		return renderers[extension] || renderers[extension.substring(1)]; // in case they supplied a .
	};

function registerRenderers(app, webDirectory) {
	var viewDir = path.join(webDirectory, &#39;views&#39;);
	app.set(&#39;views&#39;, viewDir);
	var dir = path.join(__dirname, &#39;engines&#39;),
		engines = fs.readdirSync(dir);
	engines.forEach(function (engine) {
		engine = require(path.join(dir, engine));
		if (engine.createRenderer) {
			Middleware.registerRendererEngine(app, engine);
		}
	});
	// we monkey patch express to make it easy to switch between different
	// templating engines without forcing us to register a default one
	var render = app.render;
	app.render = function (view, data, callback) {
		var ext = path.extname(view);
		if (!ext || ext === view) {
			// no extension, search for it
			var keys = Object.keys(renderers),
				found = false;
			for (var c = 0; c &lt; keys.length; c++) {
				ext = keys[c];
				var fn = path.join(viewDir, view + &#39;.&#39; + ext);
				// we found a template for a specific engine, append the
				// extension to trick express into using this specific engine
				if (fs.existsSync(fn)) {
					view += &#39;.&#39; + ext;
					found = true;
					break;
				}
			}
			if (!found) {
				return callback(new Error(&#39;Unable to find layout &quot;&#39; + view + &#39;&quot;&#39;));
			}
		}
		return render.call(app, view, data, callback);
	};
}

module.exports = Middleware;
</pre>
</body>
</html>
