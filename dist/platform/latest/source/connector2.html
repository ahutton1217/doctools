<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">&#39;use strict&#39;;

<span id='Arrow-Connector'>/**
</span> * @class Arrow.Connector
 */
var util = require(&#39;util&#39;),
	events = require(&#39;events&#39;),
	_ = require(&#39;lodash&#39;),
	async = require(&#39;async&#39;),
	fs = require(&#39;fs&#39;),
	path = require(&#39;path&#39;),
	error = require(&#39;./error&#39;),
	Collection = require(&#39;./collection&#39;),
	ORMError = error.ORMError,
	Capabilities = require(&#39;./connector/capabilities&#39;),
	utillib = require(&#39;./util&#39;),
	connectors = [],
	ConnectorClass = new events.EventEmitter(),
	delegateMethods = [
		&#39;create&#39;, &#39;save&#39;, &#39;update&#39;, &#39;upsert&#39;, &#39;findAndModify&#39;, &#39;findByID&#39;, &#39;findById&#39;, &#39;findOne&#39;, &#39;findOneMany&#39;,
		&#39;findManyByID&#39;, &#39;findManyById&#39;, &#39;findAll&#39;, &#39;find&#39;, &#39;query&#39;, &#39;delete&#39;, &#39;deleteAll&#39;, &#39;distinct&#39;, &#39;upsert&#39;,
		&#39;count&#39;, &#39;createMany&#39;, &#39;deleteMany&#39;
	];

util.inherits(Connector, events.EventEmitter);

module.exports = Connector;

function Connector(impl, config) {
	impl &amp;&amp; _.merge(this, _.omit(impl, &#39;connect&#39;, &#39;disconnect&#39;, &#39;loginRequired&#39;));
	// setup our methods to delegate through...
	var methods = impl &amp;&amp; _.pick(impl, delegateMethods);
	var self = this;
	if (methods) {
		Object.keys(methods).forEach(function connectorMethodIterator(method) {
			var fn = methods[method];
			if (typeof(fn) === &#39;function&#39;) {
				// if a function, delegate through our wrapper
				wrapDelegate(self, method, fn);
			} else {
				// just assign
				self[method] = fn;
			}
		});
	}

	// incoming constructor config should overwrite implementation
	this.config = _.merge(impl &amp;&amp; impl.config || {}, config);
	if (!this.pkginfo &amp;&amp; this.config &amp;&amp; this.config.pkginfo) {
		this.pkginfo = this.config.pkginfo;
	}

	// pull in these into the connector if we don&#39;t have them but we have them in our
	// package
	[&#39;description&#39;, &#39;version&#39;, &#39;name&#39;, &#39;author&#39;].forEach(function (k) {
		if (!self[k] &amp;&amp; self.pkginfo &amp;&amp; (k in self.pkginfo)) {
			self[k] = self.pkginfo[k];
		}
	});

	// re-map connect/disconnect for lifecycle
	this._connect = impl &amp;&amp; impl.connect;
	this._disconnect = impl &amp;&amp; impl.disconnect;
	this.connected = false;

	// incoming constructor config should overwrite implementation
	this.config = _.merge(impl &amp;&amp; impl.config || {}, config);

	// if we provided a constructor in our impl, use it
	if (this.constructor &amp;&amp; this.constructor !== Connector &amp;&amp; !this.constructor.super_) {
		this.constructor.call(this);
		Connector.constructor.call(this);
	}

	if (!this.name) {
		throw new ORMError(&#39;connector is required to have a name&#39;);
	}

	// map login required
	if (impl &amp;&amp; _.isFunction(impl.loginRequired)) {
		this.delegatedloginRequired = impl.loginRequired;
	}

<span id='Arrow-Connector-property-'>	/**
</span>	 * The arrow-orm needs another look to properly handle both findById and findOne apis.
	 * Currently when a connector version with the old findOne interface is used, the &quot;Find by id&quot;
	 * won&#39;t show up in the list of APIs for a model. So we need to manually add it.
	 */
	this.on(&#39;init-model&#39;, function (model) {
		if(!this.findByID &amp;&amp; !this.findById &amp;&amp; this.findOne) {
			model.findOneAPI = model.findByIDAPI;
		}
	}.bind(this));

	connectors.push(this);
	ConnectorClass.emit(&#39;register&#39;, this);
}

<span id='Arrow-Connector-method-toJSON'>/**
</span> * suitable for JSON.stringify
 */
Connector.prototype.toJSON = function () {
	return {
		name: this.name
	};
};

<span id='Arrow-Connector-method-inspect'>/**
</span> * suitable for util.inspect
 */
Connector.prototype.inspect = function () {
	return &#39;[object Connector:&#39; + this.name + &#39;]&#39;;
};

Connector.prototype.loginRequired = function (callback) {
	if (this.delegatedloginRequired &amp;&amp; this._promise) {
		return this.delegatedloginRequired(this.request, callback);
	} else {
		return callback(null, false);
	}
};

function wrapDelegate(connector, method, delegate_) {
	connector[&#39;delegated&#39; + method] = delegate_;
	connector[method] = function methodWrapper() {
		var delegate = this[&#39;delegated&#39; + method];
		// check if we&#39;re connected and if so, go ahead and delegate
		if (this.connected &amp;&amp; !this.loginRequired) {
			return delegate.apply(this, arguments);
		}
		// we&#39;re not connected, call through to connect before continuing
		else {
			var callback = arguments[arguments.length - 1],
				args = arguments,
				self = this,
				connect = function () {
					if (connector.connect) {
						connector.connect(function (err) {
							if (err) { return callback &amp;&amp; callback(err); }
							delegate.apply(self, args);
						});
					} else {
						delegate.apply(self, args);
					}
				};
			if (self.loginRequired) {
				self.loginRequired(function (err, required) {
					if (err) { return callback(err); }
					if (required) {
						self.login(self.request, self.response, function (err) {
							if (err) { return callback(err); }
							connect();
						});
					} else {
						connect();
					}
				});
			} else {
				connect();
			}
		}
	};
}

/*
 * Defines various connector capabilities that you can enable to progressively be guided through connector development.
 */
Connector.Capabilities = Capabilities.Capabilities;

/*
 * Generates tests based on the defined capabilities of the connector, and based upon minimal configuration.
 */
Connector.generateTests = Capabilities.generateTests;

<span id='Arrow-Connector-static-method-getConnectors'>/**
</span> * Returns the active Arrow Connectors.
 * @static
 * @returns {Array&lt;Arrow.Connector&gt;}
 */
Connector.getConnectors = function getConnectors() {
	return connectors;
};

<span id='Arrow-Connector-static-method-on'>/**
</span> * Binds a callback to an event.
 * @static
 * @param {String} name Event name
 * @param {Function} cb Callback function to execute.
 */
Connector.on = function on() {
	ConnectorClass.on.apply(ConnectorClass, arguments);
};

<span id='Arrow-Connector-static-method-removeListener'>/**
</span> * Unbinds a callback from an event.
 * @static
 * @param {String} name Event name
 * @param {Function} cb Callback function to remove.
 */
Connector.removeListener = function removeListener() {
	ConnectorClass.removeListener.apply(ConnectorClass, arguments);
};

<span id='Arrow-Connector-static-method-removeAllListeners'>/**
</span> * Unbinds all event callbacks for the specified event.
 * @static
 * @param {String} [name] Event name.  If omitted, unbinds all event listeners.
 */
Connector.removeAllListeners = function removeAllListeners() {
	ConnectorClass.removeAllListeners.apply(ConnectorClass, arguments);
};

// NOTE: this is internal and only used by the test and should never be called directly
Connector.clearConnectors = function clearConnectors() {
	connectors.length = 0;
};

/*
 * called to create a wrapper around this instance which will enforce login, etc.
 */
Connector.prototype.createRequest = function createRequest(request, response) {
	var connector = Object.create(this);
	connector.request = request;
	connector.response = response;
	connector._promise = true;

	delegateMethods.forEach(function (name) {
		var fn = connector[name];
		fn &amp;&amp; utillib.createTransactionLoggedDelegate(connector, &#39;connector&#39;, connector, name);
	});

	return connector;
};

Connector.prototype.endRequest = function createRequest() {
	this.request = this.response = null;
	this.removeAllListeners();
};

<span id='Arrow-Connector-static-method-extend'>/**
</span> * Creates a new connector.
 * @static
 * @param {Object} impl Implementation object. See the overview at the top of the page.
 * @throws {Arrow.ORMError} Missing name parameter.
 */
Connector.extend = function classExtend(impl) {
	// Validate.
	if (!impl) {
		throw new TypeError(&#39;Missing required parameter &quot;impl&quot; to Connector.extend!&#39;);
	}

	// Provide some good defaults.
	if (impl.filename) {
		if (!impl.pkginfo) {
			impl.pkginfo = _.pick(
				require(&#39;pkginfo&#39;).read(impl).package,
				&#39;name&#39;, &#39;version&#39;, &#39;description&#39;, &#39;author&#39;, &#39;license&#39;, &#39;keywords&#39;, &#39;repository&#39;
			);
		}

		// Load up (well, delayed load up)
		var modelsDir = path.resolve(path.join(impl.filename, &#39;..&#39;, &#39;..&#39;, &#39;models&#39;));
		if (!impl.models &amp;&amp; fs.existsSync(modelsDir) &amp;&amp; Connector.Arrow) {
			impl.modelsDir = modelsDir;
			// loadModelsForConnector will most likely defer loading the models until after getConnector finishes.
			// So if impl.models is undefined after this, don&#39;t fret, it will be soon.
			impl.models = Connector.Arrow.loadModelsForConnector(impl.name || impl.pkginfo.name, impl);
		}

		// Look for an example config file.
		var exampleConfig = path.resolve(path.join(impl.filename, &#39;..&#39;, &#39;..&#39;, &#39;conf&#39;, &#39;example.config.js&#39;));
		if (!impl.defaultConfig &amp;&amp; fs.existsSync(exampleConfig)) {
			impl.defaultConfig = fs.readFileSync(exampleConfig, &#39;UTF-8&#39;);
		}

		// Allow convention based loading of modules from directories.
		[&#39;lifecycle&#39;, &#39;metadata&#39;, &#39;schema&#39;, &#39;utility&#39;, &#39;methods&#39;].forEach(function (dir) {
			var subDir = path.resolve(path.join(impl.filename, &#39;..&#39;, dir));
			if (!fs.existsSync(subDir)) {
				return;
			}
			fs.readdirSync(subDir)
				.filter(function (f) {
					return f.slice(-3) === &#39;.js&#39;;
				})
				.forEach(function (f) {
					try {
						var module = require(path.join(subDir, f));
						for (var key in module) {
							if (module.hasOwnProperty(key) &amp;&amp; _.isFunction(module[key]) &amp;&amp; !impl[key]) {
								impl[key] = module[key];
							}
						}
					}
					catch (err) {
						console.error(&#39;Failed to load connector sub directory module; skipping it:&#39;);
						console.error(err);
					}
				});
		});
	}

	// if we have a logger from arrow, use it
	if (!impl.logger &amp;&amp; Connector.Arrow &amp;&amp; Connector.Arrow.getGlobal()) {
		impl.logger = Connector.Arrow.getGlobal().logger;
	}

	// Validate our capabilities.
	if (impl.capabilities) {
		Capabilities.validateCapabilities(impl);
	}

	// Recursively apply extend, so connectors can extend connectors.
	function ConnectorConstructor(config) {
		return new Connector(impl, config);
	}

	ConnectorConstructor.extend = function (extendingImpl) {
		return classExtend(_.merge(impl, extendingImpl));
	};

	return ConnectorConstructor;
};

<span id='Arrow-Connector-method-extend'>/**
</span> * Creates a new connector from this instance.
 * @param {Object} impl Implementation object. See the overview at the top of the page.
 * @throws {Arrow.ORMError} Missing name parameter.
 */
Connector.prototype.extend = function instanceExtend(impl) {
	return Connector.extend(_.merge(this, impl));
};

<span id='Arrow-Connector-method-isConnected'>/**
</span> * Returns true if connected.
 * @returns {Boolean}
 */
Connector.prototype.isConnected = function isConnected() {
	return this.connected;
};

<span id='Arrow-Connector-method-logDefaultConfig'>/**
</span> * Outputs the default connector configuration to the console.
 */
Connector.prototype.logDefaultConfig = function logDefaultConfig() {
	if (this.defaultConfig) {
		this.logger.info(&#39;The &#39; + this.name + &#39; connector recommends the following configuration. Copy and paste it in to your conf/default.js or other configuration file.&#39;);
		// Note: We do a normal console.log here because the logger can inject little characters around \t and \n.
		console.log(this.defaultConfig);
		this.logger.info(&#39;You may need to change some of the values for your particular needs.&#39;);
	}
};

<span id='Arrow-Connector-method-getPrimaryKey'>/**
</span> * Returns the primary key of a Model. Override this method to provide a different value.
 * @param {Arrow.Model} Model Model class.
 * @param {Object} record Record to check.
 * @returns {String}
 */
Connector.prototype.getPrimaryKey = function getPrimaryKey(Model, record) {
	return record[this.getPrimaryKeyColumnName()];
};

<span id='Arrow-Connector-method-connect'>/**
</span> * Connects to the external data source.
 *
 * The connect lifecycle will call the following methods before the server starts
 * (if provided by the implementation):
 *
 * 1. {@link Arrow.Connector#fetchMetadata}
 * 2. {@link Arrow.Connector#fetchConfig}
 * 3. connect
 * 4. {@link Arrow.Connector#fetchSchema}
 * @param {Function} callback Callback function passed an Error object (or null if successful).
 * The callback is invoked after each operation.
 */
Connector.prototype.connect = function (callback) {
	if (this.connected || this.config.enabled === false) {
		return callback();
	}
	var tasks = [];
	if (this.fetchMetadata) {
		tasks.push(function fetchMetadataTask(next) {
			this.fetchMetadata(function fetchMetadataTaskCallback(err, metadata) {
				if (err) { return next(err); }
				if (metadata) {
					this.metadata = _.merge(this.metadata || {}, metadata);
				}
				next();
			}.bind(this));
		}.bind(this));
	}
	else {
		// no metadata, let&#39;s just make an empty one
		tasks.push(function metadataTask(next) {
			if (!this.metadata) {
				this.metadata = {schema: undefined};
			}
			next();
		}.bind(this));
	}
	if (this.fetchConfig) {
		tasks.push(function fetchConfigTask(next) {
			this.fetchConfig(function fetchConfigTaskCallback(err, config) {
				if (err) { return next(err); }
				// basically, the constructors config should override
				// our default config from the connector
				this.config = _.merge(config, this.config);
				var possibleErr = this.validateConfig();
				if (possibleErr !== true) {
					next(possibleErr);
				}
				else {
					next();
				}
			}.bind(this));
		}.bind(this));
	}
	else {
		tasks.push(function configTask(next) {
			if (!this.config) {
				this.config = {};
			}
			var possibleErr = this.validateConfig();
			if (possibleErr !== true) {
				next(possibleErr);
			}
			else {
				next();
			}
		}.bind(this));
	}
	if (this._connect) {
		tasks.push(function connectTask(next) {
			try {
				this._connect(next);
			}
			catch (err) {
				next(err);
			}
		}.bind(this));
	}
	if (this.fetchSchema) {
		tasks.push(function fetchSchemaTask(next) {
			this.fetchSchema(function fetchSchemaTaskCallback(err, schema) {
				if (err) { return next(err); }
				if (schema) {
					this.metadata = _.merge(this.metadata || {}, {schema: schema});
					this.schema = schema;
				}
				if (!this._createdModelsFromSchema &amp;&amp; this.createModelsFromSchema &amp;&amp; (this.config.generateModelsFromSchema === undefined || this.config.generateModelsFromSchema)) {
					var proceed = function () {
						this._createdModelsFromSchema = true;
						var server = Connector.Arrow &amp;&amp; Connector.Arrow.getGlobal();
						if (server &amp;&amp; this.models) {
							server.registerModelsForConnector(this, this.models);
						}
						next();
					}.bind(this);
					if (this.createModelsFromSchema.length &gt; 0) {
						this.createModelsFromSchema(proceed);
					}
					else {
						this.createModelsFromSchema();
						proceed();
					}
				}
				else {
					next();
				}
			}.bind(this));
		}.bind(this));
	}
	async.series(tasks, function connectCallback(err) {
		if (err) { return callback(err); }
		this.connected = true;
		callback();
	}.bind(this));
};

<span id='Arrow-Connector-method-disconnect'>/**
</span> * Disconnects from the external data source.
 * @param {Function} callback Callback function to be called at the end of the operation.
 */
Connector.prototype.disconnect = function disconnect(callback) {
	if (!this.connected || this.config.enabled === false) {
		return callback();
	}
	var tasks = [];
	if (this._disconnect) {
		tasks.push(function disconnectTask(next) {
			this._disconnect(next);
		}.bind(this));
	}
	async.series(tasks, function disconnectCallback(err) {
		if (err) { return callback(err); }
		this.connected = false;
		callback();
	}.bind(this));
};

<span id='Arrow-Connector-method-validateConfig'>/**
</span> * @method validateConfig
 * Validates whether or not the config for this connector is valid, based on its metadata.
 * @returns {Boolean/Error} Returns true if the config is valid, otherwise returns an Error.
 */
Connector.prototype.validateConfig = function validateConfig() {
	var metadata = this.metadata,
		config = this.config || {};

	if (!metadata || !metadata.fields || !metadata.fields.length) {
		return true;
	}

	for (var i = 0; i &lt; metadata.fields.length; i++) {
		var field = metadata.fields[i];
		if (!config[field.name]) {
			if (field.required) {
				this.logDefaultConfig();
				return new Error(field.name + &#39; is a required config property for the &#39; + this.name + &#39; connector!&#39;);
			}
			if (field.default !== undefined) {
				config[field.name] = field.default;
			}
		}
		else if (field.validator) {
			var validator;
			if (_.isRegExp(field.validator)) {
				validator = field.validator;
			}
			else if (field.validator.type === &#39;regexp&#39;) {
				validator = new RegExp(field.validator.value, field.validator.flags);
			}
			else {
				return new Error(&#39;The connector &#39; + this.name + &#39; has an invalid validator for &#39; + field.name + &#39;!&#39;);
			}
			if (!validator.test(config[field.name])) {
				this.logDefaultConfig();
				return new Error(&#39;The value &quot;&#39; + config[field.name] + &#39;&quot; for &#39; + field.name + &#39; is invalid for the &#39; + this.name + &#39; connector!&#39;);
			}
		}
	}

	return true;
};

<span id='Arrow-Connector-method-getPrimaryKeyColumnName'>/**
</span> * Returns the column that is used as the primary key internally (not in the model, but in the native data source).
 * This is used by the model when translating the query for selecting/unselecting columns.
 * @param {Arrow.Model} Model Model class to check.
 * @returns {String} Key name in the data source used as the primary key.
 */
Connector.prototype.getPrimaryKeyColumnName = function (Model) {
	return this.idAttribute || &#39;id&#39;;
};

<span id='Arrow-Connector-method-createMany'>/**
</span> * Creates a list of instances by a set of values.
 * @since 1.2.8
 * @param {Arrow.Model} Model Model class to check.
 * @param {Array} values Set of instances to create
 * @param {Function} callback Callback passed an Error object (or null if successful).
 */
Connector.prototype.createMany = function createMany(Model, values, callback) {
	async.mapLimit(values, 4, Model.create.bind(Model), callback);
};

<span id='Arrow-Connector-method-deleteMany'>/**
</span> * Removes a list of instances by a set of ids.
 * @since 1.2.8
 * @param {Arrow.Model} Model Model class to check.
 * @param {Array} ids Set of primary keys to delete
 * @param {Function} callback Callback passed an Error object (or null if successful).
 */
Connector.prototype.deleteMany = function deleteMany(Model, ids, callback) {
	async.mapLimit(ids, 4, function (id, next) {
		Model.findByID(id, function (err, result) {
			if (err || !result) {
				return next();
			}
			Model.delete(id, next);
		});
	}.bind(Model), callback);
};

<span id='Arrow-Connector-method-findManyByID'>/**
</span> * Finds a list of instances by a set of ids.
 * @since 1.2.8
 * @param {Arrow.Model} Model Model class to check.
 * @param {Array} ids Set of primary keys to find
 * @param {Function} callback Callback passed an Error object (or null if successful).
 */
Connector.prototype.findManyByID = Connector.prototype.findManyById = Connector.prototype.findOneMany = function findOneMany(Model, ids, callback) {
	async.mapLimit(ids, 4, Model.findByID.bind(Model), callback);
};

<span id='Arrow-Connector-method-findAndModify'>/**
</span> * Performs a find and update in the same query.
 * @param {Arrow.Model} Model Model class to check.
 * @param {ArrowQueryOptions} options Query options.
 * @param {Object} doc Model fields to modify.
 * @param {Object} [args] Optional parameters.
 * @param {Boolean} [args.new=false] Set to `true` to return the new model instead of the original model.
 * @param {Boolean} [args.upsert=false] Set to `true` to allow the method to create a new model.
 * @param {Function} callback Callback passed an Error object (or null if successful) and the models.
 */
Connector.prototype.findAndModify = function findAndModify(Model, options, doc, args, callback) {
	if (_.isFunction(args)) {
		callback = args;
		args = {};
	}
	options.limit = 1;
	this.query(Model, options, function (err, result) {
		if (err) {
			return callback(err);
		}

		var hasAResult = result &amp;&amp; result.length,
			allowInserting = args.upsert || args.insert === true,
			allowUpdating = args.update === undefined || args.update === true;

		if (!hasAResult &amp;&amp; allowInserting) {
			return this.create(Model, doc, function (err, record) {
				callback(err, args.new ? record : {});
			});
		}

		if (hasAResult &amp;&amp; allowUpdating) {
			result[0].set(doc, false);
			return this.save(Model, result[0], function (err, record) {
				callback(err, args.new ? record : result[0]);
			});
		}

		callback();

	}.bind(this));
};

<span id='Arrow-Connector-method-distinct'>/**
</span> * Performs a query and returns a distinct result set based on the field(s).
 * @param {Arrow.Model} Model Model class to check.
 * @param {String} field Comma-separated list of fields.
 * @param {ArrowQueryOptions} [options] Query options.
 * @param {Function} callback Callback passed an Error object (or null if successful) and the distinct models.
 */
Connector.prototype.distinct = function distinct(Model, field, options, callback) {
	if (_.isFunction(options)) {
		callback = options;
		options = {};
	}
	this.query(Model, options, function (err, results) {
		if (err) {
			return callback(err);
		}
		else if (!results) {
			return callback();
		}
		var found = {},
			array = [],
			model = results.model,
		// fields can be a comma-separated string of each field to use in distinct
			keys = field.split(&#39;,&#39;).map(function (k) {return k.trim();});

		for (var c = 0; c &lt; results.length; c++) {
			var row = results[c],
				key;

			if (keys.length &gt; 1) {
				key = [];
				keys.forEach(function (n) {
					key.push(row.get(n));
				});
				key = key.join(&#39;,&#39;);
			}
			else {
				key = row.get(field);
			}

			if (key in found) {
				continue;
			}
			found[key] = key;
			array.push(row);
		}

		results = array;
		callback(null, Array.isArray(results) ? results : new Collection(model, results));
	});
};

<span id='Arrow-Connector-method-count'>/**
</span> * Performs a query and returns a count of the records. In the options parameter, set the
 * `distinct` property to `true` to perform a distinct count.
 * @param {Arrow.Model} Model Models to check.
 * @param {ArrowQueryOptions} [options] Query options.
 * @param {Function} callback Callback passed an Error object (or null if successful) and the number of models found.
 */
Connector.prototype.count = function count(Model, options, callback) {
	if (_.isFunction(options)) {
		callback = options;
		options = {};
	}
	this.query(Model, options, function (err, results) {
		if (err) {
			return callback(err);
		}
		else {
			var count = results.length;
			if (options.distinct) {
				var found = {};
				count = 0;
				for (var c = 0; c &lt; results.length; c++) {
					var row = results[c],
						value = row.get(options.distinct);
					if (value in found) {
						continue;
					}
					found[value] = 1;
					count++;
				}
			}
			callback(null, count);
		}
	});
};

<span id='Arrow-Connector-method-upsert'>/**
</span> * Creates or updates a model.
 * @param {Arrow.Model} Model Model to search.
 * @param {String} id ID of the model to update (or create).
 * @param {Object} document Fields to set in the model.
 * @param {Function} callback Callback passed an Error object (or null if successful) and the new model.
 */
Connector.prototype.upsert = function upsert(Model, id, document, callback) {
	Model.findByID(id, function (err, record) {
		if (err) {
			return callback(err);
		}
		if (!record &amp;&amp; document) {
			document.id = id;
			Model.create(document, callback);
		} else {
			record.set(document);
			record.save(function (err) {
				callback(err, record);
			});
		}
	});
};
</pre>
</body>
</html>
